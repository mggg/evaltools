<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools.plotting API documentation</title>
<meta name="description" content="Makes pretty pictures of districting plans, dual graphs, histograms, boxplots,
and violin plots 🎻." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>evaltools.plotting</code></h1>
</header>
<section id="section-intro">
<p>Makes pretty pictures of districting plans, dual graphs, histograms, boxplots,
and violin plots 🎻.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Makes pretty pictures of districting plans, dual graphs, histograms, boxplots,
and violin plots 🎻.
&#34;&#34;&#34;

from .drawplan import drawplan
from .drawgraph import drawgraph
from .colors import redbluecmap, flare, purples, districtr, latex
from .histogram import histogram
from .violin import violin
from .boxplot import boxplot
from .scatterplot import scatterplot
from .sealevel import sealevel
from .multidimensional import multidimensional
from .gifs import gif_multidimensional
from .bins import bins
from .annotation import arrow, ideal
from .districtnumbers import districtnumbers
from .choropleth import choropleth

__all__ = [
    &#34;drawplan&#34;,
    &#34;drawgraph&#34;,
    &#34;redbluecmap&#34;,
    &#34;flare&#34;,
    &#34;purples&#34;,
    &#34;districtr&#34;,
    &#34;histogram&#34;,
    &#34;violin&#34;,
    &#34;boxplot&#34;,
    &#34;scatterplot&#34;,
    &#34;sealevel&#34;,
    &#34;multidimensional&#34;,
    &#34;gif_multidimensional&#34;,
    &#34;arrow&#34;,
    &#34;ideal&#34;,
    &#34;bins&#34;,
    &#34;districtnumbers&#34;,
    &#34;latex&#34;,
    &#34;choropleth&#34;
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="evaltools.plotting.annotation" href="annotation.html">evaltools.plotting.annotation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.plotting.gifs" href="gifs.html">evaltools.plotting.gifs</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.plotting.utils" href="utils.html">evaltools.plotting.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.plotting.arrow"><code class="name flex">
<span>def <span class="ident">arrow</span></span>(<span>ax, text, orientation='horizontal', color='#5c676f', padding=0.1) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>For some partisan metrics, we want to draw an arrow showing where the POV-party's
advantage is. Depending on the orientation of the scores (histograms have
scores arranged horizontally, violinplots have scores arranged vertically),
we either place the arrow at the bottom left, pointing rightward, or in the
middle of the y-axis, pointing up.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object onto which the arrow's plotted.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>String plotted on top of the arrow.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Direction the arrow's pointing; acceptable
values are <code>"horizontal"</code> and <code>"vertical"</code>. Defaults to <code>"horizontal"</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color of the arrow.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Spacing between the arrow and its axis. Defaults
to <code>0.1</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow(
    ax, text, orientation=&#34;horizontal&#34;, color=defaultGray, padding=0.1
    ) -&gt; Axes:
    &#34;&#34;&#34;
    For some partisan metrics, we want to draw an arrow showing where the POV-party&#39;s
    advantage is. Depending on the orientation of the scores (histograms have
    scores arranged horizontally, violinplots have scores arranged vertically),
    we either place the arrow at the bottom left, pointing rightward, or in the
    middle of the y-axis, pointing up.

    Args:
        ax (Axes): `Axes` object onto which the arrow&#39;s plotted.
        text (str): String plotted on top of the arrow.
        orientation (str, optional): Direction the arrow&#39;s pointing; acceptable
            values are `&#34;horizontal&#34;` and `&#34;vertical&#34;`. Defaults to `&#34;horizontal&#34;`.
        color (str, optional): Color of the arrow.
        padding (float, optional): Spacing between the arrow and its axis. Defaults
            to `0.1`.
    &#34;&#34;&#34;

    if orientation == &#34;horizontal&#34;:
        x = ax.get_xlim()[0]
        y = ax.get_ylim()[0] - padding*ax.get_ylim()[1]
        horizontal_align = &#34;left&#34;
        rotation = 0
    elif orientation == &#34;vertical&#34;:
        x = ax.get_xlim()[0] -  padding*(sum(map(lambda x: abs(x), ax.get_xlim())))
        y = sum(ax.get_ylim())/2
        horizontal_align = &#34;center&#34;
        rotation = 90
    
    ax.text(x, y,
            text,
            ha=horizontal_align,
            va=&#34;center&#34;,
            color=&#34;white&#34;,
            rotation=rotation,
            size=10,
            bbox=dict(
                boxstyle=&#34;rarrow,pad=0.3&#34;,
                fc=color,
                alpha=1,
                ec=&#34;black&#34;,
                )
            )
    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.bins"><code class="name flex">
<span>def <span class="ident">bins</span></span>(<span>scores, width=None, labels=8) ‑> Tuple[<built-in function array>, List, List, Union[float, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get necessary information for histograms. If we're working with only a few
discrete, floating point values, then set the bin width to be relatively thin.
Otherwise, adaptively set the bin width to the scale of our data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scores</code></strong> :&ensp;<code>list</code></dt>
<dd>The collection of all observations.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the bins.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of histograms to be labeled.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple consisting of the histogram bins, the bins that are ticked, the
labels for the bins that are ticked, and the bin width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bins(scores, width=None, labels=8) -&gt; Tuple[array, List, List, Union[float, int]]:
    &#34;&#34;&#34;
    Get necessary information for histograms. If we&#39;re working with only a few
    discrete, floating point values, then set the bin width to be relatively thin.
    Otherwise, adaptively set the bin width to the scale of our data.
    
    Args:
        scores (list): The collection of all observations.
        width (int, optional): The width of the bins.
        labels (int, optional): The number of histograms to be labeled.

    Returns:
        A tuple consisting of the histogram bins, the bins that are ticked, the
        labels for the bins that are ticked, and the bin width.
    &#34;&#34;&#34;
    # Get the minimum score and maximum score
    minscore, maxscore = min(scores), max(scores)

    # Calculate bin width using Gabe&#39;s logarithmic heuristic
    # TODO: Test this with real score data and see how it looks
    if not width:
        width = 10 ** (np.floor(np.log10(maxscore - minscore)) - 1)
        if width == 0.01:
            width /= 5
        if width == 0.1:
            width = 1
        if width &gt;= 1:
            width = int(width)

    hist_bins = np.arange(minscore, maxscore + 2 * width, width)
    label_interval = max(int(len(hist_bins) / labels), 1)
    tick_bins, tick_labels = [], []
    for i, x in enumerate(hist_bins[:-1]):
        if i % label_interval == 0:
            tick_labels.append(x)
            tick_bins.append(x + width / 2)
    for i, label in enumerate(tick_labels):
        if type(label) == np.float64:
            tick_labels[i] = round(label, 2)
    
    return hist_bins, tick_bins, tick_labels, width</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.boxplot"><code class="name flex">
<span>def <span class="ident">boxplot</span></span>(<span>ax, scores, xticklabels=None, labels=None, proposed_info={}, percentiles=(1, 99), rotation=0, ticksize=12, jitter=0.3333333333333333) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Plot boxplots, which takes <code>scores</code> — a dictionary where each value
(corresponding to an ensemble, citizens' ensemble, or proposed plans),
will be a list of lists, where each sublist will be its own box. Proposed
scores will be plotted as colored circles on their respective box. Color the
boxplots conditioned on the kind of the scores (ensemble or citizen), and
trim each sublist to only the values between the specified percentiles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object on which the boxplots are plotted.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keys of <code>ensemble</code>, <code>citizen</code>, <code>proposed</code>
which map to lists of numerical scores.</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>;
the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name in <code>names</code>.</dd>
<dt><strong><code>percentiles</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Observations outside this range of
percentiles are ignored. Defaults to <code>(1, 99)</code>, such that observations
between the 1st and 99th percentiles (inclusive) are included, and
all others are ignored.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tick labels are rotated <code>rotation</code> degrees
<em>counterclockwise</em>.</dd>
<dt><strong><code>ticksize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size for tick labels.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>When there is more than one proposed plan,
adjust its detail points by a value drawn from <span><span class="MathJax_Preview">\mathcal U (-\epsilon,
\epsilon)</span><script type="math/tex">\mathcal U (-\epsilon,
\epsilon)</script></span> where <span><span class="MathJax_Preview">\epsilon = </span><script type="math/tex">\epsilon = </script></span> <code>jitter</code>.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>x- and y-axis labels, if desired.</dd>
<dt><strong><code>xticklabels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Labels for the boxes, default to integers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Axes</code> object on which the violins are plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boxplot(
        ax, scores, xticklabels=None, labels=None, proposed_info={}, percentiles=(1,99), rotation=0,
        ticksize=12, jitter=1/3
    ) -&gt; Axes:
    r&#34;&#34;&#34;
    Plot boxplots, which takes `scores` — a dictionary where each value
    (corresponding to an ensemble, citizens&#39; ensemble, or proposed plans),
    will be a list of lists, where each sublist will be its own box. Proposed
    scores will be plotted as colored circles on their respective box. Color the
    boxplots conditioned on the kind of the scores (ensemble or citizen), and
    trim each sublist to only the values between the specified percentiles.

    Args:
        ax (Axes): `Axes` object on which the boxplots are plotted.
        scores (dict): Dictionary with keys of `ensemble`, `citizen`, `proposed`
            which map to lists of numerical scores.
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`;
            the \(i\)th color in `color` corresponds to the \(i\)th name in `names`.
        percentiles (tuple, optional): Observations outside this range of
            percentiles are ignored. Defaults to `(1, 99)`, such that observations
            between the 1st and 99th percentiles (inclusive) are included, and
            all others are ignored.
        rotation (float, optional): Tick labels are rotated `rotation` degrees
            _counterclockwise_.
        ticksize (float, optional): Font size for tick labels.
        jitter (float, optional): When there is more than one proposed plan,
            adjust its detail points by a value drawn from \(\mathcal U (-\epsilon,
            \epsilon)\) where \(\epsilon = \) `jitter`.
        labels (list, optional): x- and y-axis labels, if desired.
        xticklabels (list, optional): Labels for the boxes, default to integers.

    Returns:
        `Axes` object on which the violins are plotted.
    &#34;&#34;&#34;
    # Get all the scores into one list; pick a face color.
    ensemble = scores[&#34;ensemble&#34;] if scores[&#34;ensemble&#34;] else scores[&#34;citizen&#34;]
    facecolor = defaultGray if scores[&#34;ensemble&#34;] else citizenBlue

    # Specify the boxplots&#39; style.
    boxstyle = {
        &#34;lw&#34;: 2,
        &#34;color&#34;: facecolor,
    }

    # Plot boxplots.
    ax.boxplot(
        ensemble,
        whis=percentiles,
        boxprops=boxstyle,
        whiskerprops=boxstyle,
        capprops=boxstyle,
        medianprops=boxstyle,
        showfliers=False,
    )

    # Set xticks, xlabels, and x-axis limits
    if not xticklabels:
        xticklabels = range(1, len(scores[&#39;ensemble&#39;]) + 1)
    ax.set_xticks(range(1, len(ensemble) + 1))
    ax.set_xticklabels(xticklabels, fontsize=ticksize, rotation=rotation)
    ax.set_xlim(0.5, len(ensemble) + 0.5)

    # Plot each proposed plan individually, adjusting its detail points by
    # a value drawn from the uniform distribution of specified width centered on
    # the index of the violin.
    if scores[&#34;proposed&#34;]:
        for boxplot in range(len(scores[&#34;proposed&#34;])):
            for plan, score in enumerate(scores[&#34;proposed&#34;][boxplot]):
                # Horizontally jitter proposed scores if there are multiple scores
                # at the same height.
                jitter_val = random.uniform(-jitter, jitter) if scores[&#34;proposed&#34;][boxplot].count(score) &gt; 1 else 0
                ax.scatter(
                    boxplot + 1 + jitter_val,
                    score,
                    color=districtr(plan+1).pop(),
                    edgecolor=&#39;black&#39;,
                    s=100,
                    alpha=0.9,
                    label=proposed_info[&#34;names&#34;][plan] if boxplot == 0 else None,
                )
        ax.legend()
        ax.grid(axis=&#39;x&#39;)

    if labels:
        ax.set_xlabel(labels[0], fontsize=24)
        ax.set_ylabel(labels[1], fontsize=24)
    
    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.choropleth"><code class="name flex">
<span>def <span class="ident">choropleth</span></span>(<span>geometries, districts=None, assignment=None, demographic='BVAP', overlays=[], cmap='Purples', cbartitle=None, numbers=True, lw=0.125, fontsize=15, min=0, max=1, interval=0.1, colorbar=True) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Visualization of population shares or totals in a state's map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>GeoDataFrame</code></dt>
<dd>Base geometries for the state. Population
shares or totals will be drawn at this level (i.e. statistics are
reported at this base geometric level).</dd>
<dt><strong><code>districts</code></strong> :&ensp;<code>GeoDataFrame</code>, optional</dt>
<dd>Geometries for the districting plan.
Assumes one geometry per district. </dd>
<dt><strong><code>assignment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Required argument when <code>districts</code> are
provided. Column of <code>districts</code> which defines the districing plan. </dd>
<dt><strong><code>demographic</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The string representing the demographic to
be shown on the map. The string should specify a column in <code>geometries</code>.
<em>This column must contain values in <span><span class="MathJax_Preview">[0,1]</span><script type="math/tex">[0,1]</script></span>.</em></dd>
<dt><strong><code>overlays</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of GeoDataFrames desired to be overlaid on
the map. Some options would include overlaying district assignments,
blocks, VTDs, or counties. The first set of geometries in the list
will be overlaid in the lightest color, and last will be overlaid in
the darkest color.
cmap (string/ListedColorMap, optional): Defines which colormap to use.
Defaults to matplotlib's <code>Purples</code> colormap. Can be a string which
specifies a named matplotlib colormap or a <code>ListedColormap</code> with the
appropriate number of bins; by default, this is 10.</dd>
<dt><strong><code>cbartitle</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Title for the colorbar. Defaults to
<code>demographic</code>.</dd>
<dt><strong><code>numbers</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, plot district names (as defined by
<code>assignment</code>) at districts' centroids. May only be <code>True</code> when
<code>districts</code> is not <code>None</code>.</dd>
<dt><strong><code>lw</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The base geometries' line widths.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The lower limit of the data points; defaults to 0.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The upper limit of the data points; defaults to 1.</dd>
<dt><strong><code>interval</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The width of the interval; a bin.</dd>
<dt><strong><code>colorbar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Do we include the color bar?</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A matplotlib <code>Axes</code> object visualizing a choropleth map with the provided
overlays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choropleth(
        geometries, districts=None, assignment=None, demographic=&#34;BVAP&#34;,
        overlays=[], cmap=&#34;Purples&#34;, cbartitle=None, numbers=True, lw=1/8,
        fontsize=15, min=0, max=1, interval=1/10, colorbar=True
    ) -&gt; Axes:
    &#34;&#34;&#34;
    Visualization of population shares or totals in a state&#39;s map.
    
    Args:
        geometries (GeoDataFrame): Base geometries for the state. Population
            shares or totals will be drawn at this level (i.e. statistics are
            reported at this base geometric level).
        districts (GeoDataFrame, optional): Geometries for the districting plan.
            Assumes one geometry per district. 
        assignment (str, optional): Required argument when `districts` are
            provided. Column of `districts` which defines the districing plan. 
        demographic (str, optional): The string representing the demographic to
            be shown on the map. The string should specify a column in `geometries`.
            *This column must contain values in \([0,1]\).*
        overlays (list, optional): A list of GeoDataFrames desired to be overlaid on
            the map. Some options would include overlaying district assignments,
            blocks, VTDs, or counties. The first set of geometries in the list
            will be overlaid in the lightest color, and last will be overlaid in
            the darkest color.
            cmap (string/ListedColorMap, optional): Defines which colormap to use.
            Defaults to matplotlib&#39;s `Purples` colormap. Can be a string which
            specifies a named matplotlib colormap or a `ListedColormap` with the
            appropriate number of bins; by default, this is 10.
        cbartitle (string, optional): Title for the colorbar. Defaults to
            `demographic`.
        numbers (bool, optional): If `True`, plot district names (as defined by
            `assignment`) at districts&#39; centroids. May only be `True` when
            `districts` is not `None`.
        lw (float, optional): The base geometries&#39; line widths.
        min (float, optional): The lower limit of the data points; defaults to 0.
        max (float, optional): The upper limit of the data points; defaults to 1.
        interval (float, optional): The width of the interval; a bin.
        colorbar (bool, optional): Do we include the color bar?

    Returns:
        A matplotlib `Axes` object visualizing a choropleth map with the provided
        overlays.
    &#34;&#34;&#34;
    # Get the figure and base axis sizes.
    fig, base = plt.subplots(1, 1, figsize=(10,10))
    
    # Get the title for the colorbar.
    if cbartitle is None: cbartitle = demographic
    
    # Set minimum and maximum values.
    boundaries = np.arange(min, max+interval, interval)
    ticks = np.arange(min, max+interval, interval/2)[:-1]
    labels = [
        f&#34;{int(ticks[i-1]*100)} — {int(ticks[i+1]*100)}%&#34; if i%2 else &#34;&#34;
        for i in range(len(ticks))
    ]
    
    # Set the color map, based on user preference or default (purples). If we
    # can&#39;t find the correct colormap, then create our own.
    if type(cmap) == str: colorbarmap = plt.cm.get_cmap(cmap, len(boundaries))
    else: colorbarmap = cmap

    norm = mpl.colors.BoundaryNorm(boundaries, colorbarmap.N)
        
    # Plot geometries!
    geometries.plot(
        column=demographic, 
        cmap=cmap,
        edgecolor=&#34;lightgray&#34;, 
        linewidth=lw,
        vmin=min, 
        vmax=max,
        ax=base
    )

    # Create and plot the colorbar on the right side of the figure.
    if colorbar:
        cbar = fig.colorbar(
            plt.cm.ScalarMappable(cmap=colorbarmap, norm=norm), shrink=0.5,
            location=&#34;right&#34;, ax=base, ticks=ticks
        )
        cbar.ax.set_yticklabels(labels)
        cbar.ax.set_ylabel(cbartitle)
        cbar.ax.yaxis.set_label_position(&#34;left&#34;)
        cbar.ax.tick_params(size=0)
    
    # Plot each of the overlays, adjusting CRSes and applying colors as we go.
    for idx, geom in enumerate(overlays):
        geom = geom.to_crs(geometries.crs)
        geom.boundary.plot(edgecolor=overlaycolors[-(idx+1)], linewidth = 1/4, ax =base)
    
    # If district geometries are provided, plot them as well.
    if districts is not None:
        districts.plot( 
            edgecolor=&#34;black&#34;,
            linewidth=3/2, 
            ax=base,
            color=&#34;None&#34;
        )

    # If district numbers are to be plotted, plot those too!
    if numbers: base = districtnumbers(base, districts, assignment=assignment, fontsize=fontsize)

    # Turn plot vertical/horizontal axes off and return base Axes.
    base.set_axis_off()

    return base, None if not colorbar else cbar</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.districtnumbers"><code class="name flex">
<span>def <span class="ident">districtnumbers</span></span>(<span>base, districts, assignment='DISTRICTN', boxstyle='circle,pad=0.2', fc='wheat', ec='black', lw=0.16666666666666666, fontsize=15) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Plots district numbers on top of overlaid district geometries.</p>
<p>TODO: change (x,y) coordinate pairs to representative points rather than
centroids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base</code></strong> :&ensp;<code>Axes</code></dt>
<dd>Base <code>Axes</code> object for the plot.</dd>
<dt><strong><code>districts</code></strong> :&ensp;<code>GeoDataFrame</code></dt>
<dd>Geometries for the districting plan. Assumes
there is one geometry for each district.</dd>
<dt><strong><code>assignment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column of <code>districts</code> which defines the
districting plan.</dd>
<dt><strong><code>boxstyle</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Sets the box style for the district number
markers. Defaults to circles with 0.2pt padding.</dd>
<dt><strong><code>fc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>District marker face color. Defaults to <code>"wheat"</code>.</dd>
<dt><strong><code>ec</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>District marker edge color. Defaults to <code>"black"</code>.</dd>
<dt><strong><code>lw</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>District marker edge width. Defaults to 1/6pt.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>District marker font size. Defaults to 15pt.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Base axes object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def districtnumbers(
        base, districts, assignment=&#34;DISTRICTN&#34;, boxstyle=&#34;circle,pad=0.2&#34;,
        fc=&#34;wheat&#34;, ec=&#34;black&#34;, lw=1/6, fontsize=15
    ) -&gt; Axes:
    &#34;&#34;&#34;
    Plots district numbers on top of overlaid district geometries.

    TODO: change (x,y) coordinate pairs to representative points rather than
    centroids.

    Args:
        base (Axes): Base `Axes` object for the plot.
        districts (GeoDataFrame): Geometries for the districting plan. Assumes
            there is one geometry for each district.
        assignment (str, optional): Column of `districts` which defines the
            districting plan.
        boxstyle (str, optional): Sets the box style for the district number
            markers. Defaults to circles with 0.2pt padding.
        fc (str, optional): District marker face color. Defaults to `&#34;wheat&#34;`.
        ec (str, optional): District marker edge color. Defaults to `&#34;black&#34;`.
        lw (float, optional): District marker edge width. Defaults to 1/6pt.
        fontsize (float, optional): District marker font size. Defaults to 15pt.

    Returns:
        Base axes object.
    &#34;&#34;&#34;
    for district, identifier in zip(districts[&#34;geometry&#34;], districts[assignment]):
        x, y = list(district.representative_point().coords)[0]
        base.annotate(
            identifier, (x,y), xytext=(x,y), xycoords=&#34;data&#34;, fontsize=fontsize, 
            ha=&#34;center&#34;, va=&#34;center&#34;,
            bbox=dict(
                boxstyle=boxstyle, fc=fc, ec=ec, alpha=1, linewidth=lw
            )
        )

    return base</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.districtr"><code class="name flex">
<span>def <span class="ident">districtr</span></span>(<span>N)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def districtr(N):
    colors = [
        &#34;#0099cd&#34;, &#34;#ffca5d&#34;, &#34;#00cd99&#34;, &#34;#99cd00&#34;, &#34;#cd0099&#34;, &#34;#9900cd&#34;, &#34;#8dd3c7&#34;,
        &#34;#bebada&#34;, &#34;#fb8072&#34;, &#34;#80b1d3&#34;, &#34;#fdb462&#34;, &#34;#b3de69&#34;, &#34;#fccde5&#34;, &#34;#bc80bd&#34;,
        &#34;#ccebc5&#34;, &#34;#ffed6f&#34;, &#34;#ffffb3&#34;, &#34;#a6cee3&#34;, &#34;#1f78b4&#34;, &#34;#b2df8a&#34;, &#34;#33a02c&#34;,
        &#34;#fb9a99&#34;, &#34;#e31a1c&#34;, &#34;#fdbf6f&#34;, &#34;#ff7f00&#34;, &#34;#cab2d6&#34;, &#34;#6a3d9a&#34;, &#34;#b15928&#34;,
        &#34;#64ffda&#34;, &#34;#00B8D4&#34;, &#34;#A1887F&#34;, &#34;#76FF03&#34;, &#34;#DCE775&#34;, &#34;#B388FF&#34;, &#34;#FF80AB&#34;,
        &#34;#D81B60&#34;, &#34;#26A69A&#34;, &#34;#FFEA00&#34;, &#34;#6200EA&#34;
    ]

    repeats = math.ceil(N/len(colors))
    tail = [hexshift(c) for c in colors*(repeats-1)]
    return (colors + (tail if tail else []))[:N]</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.drawgraph"><code class="name flex">
<span>def <span class="ident">drawgraph</span></span>(<span>G, ax=None, x='INTPTLON20', y='INTPTLAT20', components=False, node_size=1, **kwargs) ‑> Union[matplotlib.axes._axes.Axes, List[Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a gerrychain Graph object. Returns a single Axes object (for dual
graphs drawn whole) and lists of <code>(Figure, Axes)</code> pairs for graphs drawn
component-wise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>Graph</code></dt>
<dd>The dual graph to draw.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code>, optional</dt>
<dd><code>matplotlib.axes.Axes</code> object. If not passed, one
is created.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Vertex property used as the horizontal (E-W) coordinate.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Vertex property used as the vertical (N-S) coordinate.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, the graph is assumed to have
more than one connected component (e.g. Michigan) and is drawn
component-wise and rather than return a single <code>Axes</code> object, return
a list of <code>(Figure, Axes)</code> pairs. If something is passed to <code>ax</code>, the
same Axes instance is used for each new Figure.</dd>
<dt><strong><code>node_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Specifies the default size of a vertex.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Arguments to be passed to <code>nx.draw()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of <code>matplotlib</code> <code>(Figure, Axes)</code> objects, or if <code>components</code> is
<code>True</code>, returns a list of <code>(Figure, Axes)</code> objects corresponding to each
component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawgraph(
        G, ax=None, x=&#34;INTPTLON20&#34;, y=&#34;INTPTLAT20&#34;, components=False, node_size=1,
        **kwargs
    ) -&gt; Union[Axes, List[Tuple[Figure,Axes]]]:
    &#34;&#34;&#34;
    Draws a gerrychain Graph object. Returns a single Axes object (for dual
    graphs drawn whole) and lists of `(Figure, Axes)` pairs for graphs drawn
    component-wise.

    Args:
        G (Graph): The dual graph to draw.
        ax (Axes, optional): `matplotlib.axes.Axes` object. If not passed, one
            is created.
        x (str, optional): Vertex property used as the horizontal (E-W) coordinate.
        y (str, optional): Vertex property used as the vertical (N-S) coordinate.
        components (bool, optional): If `True`, the graph is assumed to have
            more than one connected component (e.g. Michigan) and is drawn
            component-wise and rather than return a single `Axes` object, return
            a list of `(Figure, Axes)` pairs. If something is passed to `ax`, the
            same Axes instance is used for each new Figure.
        node_size (float, optional): Specifies the default size of a vertex.
        kwargs (dict, optional): Arguments to be passed to `nx.draw()`.

    Returns:
        A tuple of `matplotlib` `(Figure, Axes)` objects, or if `components` is
        `True`, returns a list of `(Figure, Axes)` objects corresponding to each
        component.
    &#34;&#34;&#34;
    # Create a mapping from identifiers to positions.
    positions = {
        v: (properties[x], properties[y])
        for v, properties in G.nodes(data=True)
    }

    # If `components` is true, plot the graph component-wise. Otherwise plot
    # normally. First, set some properties common to both graphs.
    properties = {&#34;pos&#34;: positions, &#34;node_size&#34;: node_size }

    # Initialize `pairs` to None.
    pairs = None

    if not components:
        if not ax: axes = plt.axes()
        else: axes = ax
        nx.draw(G, ax=axes, **properties, **kwargs)
    else:
        # Create lists for figures and axes.
        pairs = []

        connected_components = [c for c in nx.connected_components(G)]
        for component in connected_components:
            # Create a new Figure object for each component.
            fig = plt.figure()
            if not ax: ax = plt.axes()

            # Plot the graph.
            subgraph = G.subgraph(component)
            nx.draw(subgraph, ax=ax, **properties, **kwargs)

            # Add them to their respective lists.
            pairs.append((fig, ax))

    return pairs if pairs else axes</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.drawplan"><code class="name flex">
<span>def <span class="ident">drawplan</span></span>(<span>districts, assignment, overlays=[], colors=None, numbers=False, lw=0.5, fontsize=15, edgecolor='black') ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Visualizes the districting plan defined by <code>assignment</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>districts</code></strong> :&ensp;<code>GeoDataFrame</code></dt>
<dd>Geometries for the districting plan. Assumes
there is one geometry for each district.</dd>
<dt><strong><code>assignment</code></strong> :&ensp;<code>str</code></dt>
<dd>Column of <code>districts</code> which defines the districting plan.</dd>
<dt><strong><code>overlays</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of GeoDataFrames to be plotted over the
districts.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Column name which specifies colors for each district.</dd>
<dt><strong><code>numbers</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, plots district names (as defined by
<code>assignment</code>) at districts' centroids. Defaults to <code>False</code>.</dd>
<dt><strong><code>lw</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Line thickness if there are more than 20 districts.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>District-number font size; passed to
<code><a title="evaltools.plotting.districtnumbers" href="#evaltools.plotting.districtnumbers">districtnumbers()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>matplotlib</code> <code>Axes</code> object for the geometries attached to <code>districts</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawplan(
        districts, assignment, overlays=[], colors=None, numbers=False, lw=1/2,
        fontsize=15, edgecolor=&#34;black&#34;
    ) -&gt; Axes:
    &#34;&#34;&#34;
    Visualizes the districting plan defined by `assignment`.

    Args:
        districts (GeoDataFrame): Geometries for the districting plan. Assumes
            there is one geometry for each district.
        assignment (str): Column of `districts` which defines the districting plan.
        overlays (list, optional): A list of GeoDataFrames to be plotted over the
            districts.
        colors (str, optional): Column name which specifies colors for each district.
        numbers (bool, optional): If `True`, plots district names (as defined by
            `assignment`) at districts&#39; centroids. Defaults to `False`.
        lw (float, optional): Line thickness if there are more than 20 districts.
        fontsize (float, optional): District-number font size; passed to
            `districtnumbers`.
    
    Returns:
        A `matplotlib` `Axes` object for the geometries attached to `districts`.
    &#34;&#34;&#34;
    # Sort districts by their assignment and add a column specifying the color
    # index.
    N = len(districts)
    districts = districts.to_crs(&#34;epsg:3857&#34;)
    districts[assignment] = districts[assignment].astype(int)
    districts = districts.sort_values(by=assignment)
    districts[&#34;colorindex&#34;] = list(range(N))

    # Assign colors.
    districts[&#34;color&#34;] = districtr(N)

    # Plot the districts.
    base = districts.plot(
        color=districts[colors if colors else &#34;color&#34;],
        edgecolor=&#34;black&#34;,
        linewidth=lw if lw is not None else 1
    )

    # If we have overlaid geometries, plot those too.
    if overlays:
        for overlay in overlays:
            overlay = overlay.to_crs(districts.crs)
            overlay.plot(color=&#34;None&#34;, edgecolor=edgecolor, linewidth=1/8, ax=base)
    
    # If the `numbers` flag is passed, plot the numbers for each district.
    if numbers: base = districtnumbers(base, districts, assignment=assignment, fontsize=fontsize)

    # Turn plot axes off.
    plt.axis(&#34;off&#34;)

    return base</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.flare"><code class="name flex">
<span>def <span class="ident">flare</span></span>(<span>n) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of colors based on the <code><a title="evaltools.plotting.flare" href="#evaltools.plotting.flare">flare()</a></code> Matplotlib/seaborn colormap.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of colors to generate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of RGB triples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flare(n) -&gt; list:
    &#34;&#34;&#34;
    Returns a list of colors based on the `flare` Matplotlib/seaborn colormap.

    Args:
        n (int): Number of colors to generate.

    Returns:
        List of RGB triples.
    &#34;&#34;&#34;
    return list(sns.color_palette(&#34;flare&#34;, as_cmap=False, n_colors=n))</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.gif_multidimensional"><code class="name flex">
<span>def <span class="ident">gif_multidimensional</span></span>(<span>data, proposed_info={}, labels=['X values', 'Y values', 'Histogram values'], filename='testfile', folder='test', limits=None, DPI=150, figsize=(12, 8))</span>
</code></dt>
<dd>
<div class="desc"><p>Plot many multidimensional figures in their own <code>{folder}/{filename}/</code> directory. Each
file will represent one ensemble of plans, and this will be stitched together to create
a gif.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keys of <code>xs</code>, <code>ys</code>, <code>hists</code>, each one a list of length
number of frames/ensembles, where each element is a list of all values in the ensemble.</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>,
<code>x</code>, <code>y</code>, <code>hist</code>; the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the
<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name in <code>names</code>, which corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th value in
<code>x</code>, <code>y</code>, and <code>hist</code>.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name for the final gif, and for the folder the gif's frames are stored in</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code></dt>
<dd>Folder containing all the frames/gifs.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Figure size</dd>
</dl>
<p>Returns: None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gif_multidimensional(data, 
                         proposed_info={}, 
                         labels=[&#34;X values&#34;, &#34;Y values&#34;, &#34;Histogram values&#34;],
                         filename=&#34;testfile&#34;, 
                         folder=&#34;test&#34;, 
                         limits=None,
                         DPI=150,
                         figsize=(12,8),
                         ):
    r&#34;&#34;&#34;
    Plot many multidimensional figures in their own `{folder}/{filename}/` directory. Each
    file will represent one ensemble of plans, and this will be stitched together to create
    a gif.

    Args:
        data (dict): Dictionary with keys of `xs`, `ys`, `hists`, each one a list of length
            number of frames/ensembles, where each element is a list of all values in the ensemble.
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`, 
            `x`, `y`, `hist`; the \(i\)th color in `color` corresponds to the 
            \(i\)th name in `names`, which corresponds to the \(i\)th value in 
            `x`, `y`, and `hist`.
        filename (str): Name for the final gif, and for the folder the gif&#39;s frames are stored in
        folder (str): Folder containing all the frames/gifs.
        figsize (tuple, optional): Figure size

    Returns: None.
    &#34;&#34;&#34;
    xs = data[&#39;xs&#39;]
    ys = data[&#39;ys&#39;]
    hists = data[&#39;hists&#39;]
    assert len(xs) == len(ys) == len(hists)
    lower_bound = 1
    upper_bound = 1
    x_limits = (lower_bound * min_of_min(xs), upper_bound * max_of_max(xs))
    y_limits = (lower_bound * min_of_min(ys), upper_bound * max_of_max(ys))
    hist_limits = (int(lower_bound * min_of_min(hists)), int(upper_bound * max_of_max(hists)))
    limits = [x_limits, y_limits, hist_limits] if not limits else limits
    
    save = {
        &#34;folder&#34;:folder,
        &#34;filename&#34;:filename,
        &#34;DPI&#34;:DPI,
    }
    print(&#34;Generating PNGs...&#34;)
    for i in tqdm(range(len(xs))):
        save[&#34;frame&#34;] = i
        multidimensional(xs[i],
                         ys[i],
                         hists[i],
                         labels=labels,
                         limits=limits,
                         proposed_info=proposed_info,
                         figsize=figsize,
                         save=save,
                        )
    print(&#34;Generating gif...&#34;)
    images = []
    path = f&#34;{save[&#39;folder&#39;]}/{save[&#39;filename&#39;]}/{save[&#39;filename&#39;]}_&#34;
    output = f&#34;{save[&#39;folder&#39;]}/{save[&#39;filename&#39;]}.gif&#34;
    for i in tqdm(range(len(xs))):
        images.append(imageio.imread(f&#34;{path}{i}.png&#34;))
    imageio.mimsave(output, images)
    return</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.histogram"><code class="name flex">
<span>def <span class="ident">histogram</span></span>(<span>ax, scores, label=None, limits=(), proposed_info={}, ticksize=12, fontsize=24, jitter=False, bin_width=None) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a histogram with the ensemble scores in bins and the proposed plans'
scores as vertical lines. If there are many unique values, use a white border
on the bins to distinguish, otherwise reduce the bin width to 80%.</p>
<p>TODO: refactor <code>proposed_info</code> later to use more python builtin tools.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object on which the histogram is plotted.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keys of <code>ensemble</code>, <code>citizen</code>, <code>proposed</code>
which map to lists of numerical scores.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>String for x-axis label.</dd>
<dt><strong><code>limits</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>X-axis limits (specify to force histogram to extend to
these limits).</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>;
the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name in <code>names</code>.</dd>
<dt><strong><code>ticksize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size of tick labels.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size of x-axis label.</dd>
<dt><strong><code>jitter</code></strong></dt>
<dd>(Boolean, optional): If True, horizontally jitter proposed plans if they share the
same value</dd>
<dt><strong><code>bin_width</code></strong></dt>
<dd>(float, optional): Manually set histogram bin width, if preferred.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Axes object on which the histogram is plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def histogram(ax, 
              scores, 
              label=None, 
              limits=tuple(), 
              proposed_info={}, 
              ticksize=12, 
              fontsize=24,
              jitter=False,
              bin_width=None) -&gt; Axes:
    r&#34;&#34;&#34;
    Plot a histogram with the ensemble scores in bins and the proposed plans&#39;
    scores as vertical lines. If there are many unique values, use a white border
    on the bins to distinguish, otherwise reduce the bin width to 80%.

    TODO: refactor `proposed_info` later to use more python builtin tools.

    Args:
        ax (Axes): `Axes` object on which the histogram is plotted.
        scores (dict): Dictionary with keys of `ensemble`, `citizen`, `proposed`
            which map to lists of numerical scores.
        label (str, optional): String for x-axis label.
        limits (tuple, optional): X-axis limits (specify to force histogram to extend to 
            these limits).
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`;
            the \(i\)th color in `color` corresponds to the \(i\)th name in `names`.
        ticksize (float, optional): Font size of tick labels.
        fontsize (float, optional): Font size of x-axis label.
        jitter: (Boolean, optional): If True, horizontally jitter proposed plans if they share the
            same value
        bin_width: (float, optional): Manually set histogram bin width, if preferred.
        
    Returns:
        Axes object on which the histogram is plotted.
    &#34;&#34;&#34;
    # Put all scores into a single list.
    all_scores = scores[&#34;ensemble&#34;] + scores[&#34;citizen&#34;] + scores[&#34;proposed&#34;]
    if not bin_width:
        # Get the necessary bins, ticks, labels, and bin width.
        hist_bins, tick_bins, tick_labels, bin_width = bins(set(all_scores).union(limits))
    else:
        hist_bins, tick_bins, tick_labels, bin_width = bins(set(all_scores).union(limits), bin_width)

    # Set xticks and xticklabels.
    ax.set_xticks(tick_bins)
    ax.set_xticklabels(tick_labels, fontsize=ticksize)

    # Adjust the visual width of the bins according to the number of observations;
    # if we have few scores, we want to adjust the look of the bins to make the
    # plots more readable. Also adjust the opacity of the ensembles if we include
    # a citizen ensemble.
    rwidth    = 0.8     if len(set(scores)) &lt; 20 else 1
    edgecolor = &#34;black&#34; if len(set(scores)) &lt; 20 else &#34;white&#34;
    alpha = 0.7 if scores[&#34;ensemble&#34;] and scores[&#34;citizen&#34;] else 1

    for kind in [&#34;ensemble&#34;, &#34;citizen&#34;]:
        if scores[kind]:
            ax.hist(
                scores[kind],
                bins=hist_bins,
                color=defaultGray if kind == &#34;ensemble&#34; else citizenBlue,
                rwidth=rwidth,
                edgecolor=edgecolor,
                alpha=alpha,
                density=True,
            )
    if scores[&#34;proposed&#34;]:
        for i, s in enumerate(scores[&#34;proposed&#34;]):
            if jitter and scores[&#34;proposed&#34;].count(s) &gt; 1:
                jitter_val = random.uniform(-bin_width/4, bin_width/4)
            else:
                jitter_val = 0

            # Plot vertical line.
            ax.axvline(
                s + bin_width / 2 + jitter_val,
                color=districtr(i+1).pop(),
                lw=2,
                label=f&#34;{proposed_info[&#39;names&#39;][i]}: {round(s,2)}&#34;,
            )
        
        ax.legend()
    if label:
        ax.set_xlabel(label, fontsize=fontsize)
    ax.get_yaxis().set_visible(False)
    if limits:
        ax.set_xlim(limits)
    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.ideal"><code class="name flex">
<span>def <span class="ident">ideal</span></span>(<span>ax, label, placement, orientation, color='#5c676f', alpha=0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a vertical line, horizontal line, or band indicating the ideal value
(or range of values) for the provided score.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object onto which the line's plotted.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>Label for the ideal score.</dd>
<dt><strong><code>placement</code></strong> :&ensp;<code>float,tuple</code></dt>
<dd>If plotting a line, a single value; if plotting
a band, a tuple of (start, end) values.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>Indicates the direction of the line or band. Acceptable
values are <code>"horizontal"</code> or <code>"vertical"</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color of the line or band. Defaults to <code>defaultGray</code>.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Opacity of the line or band. Defaults to <code>0.1</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ideal(ax, label, placement, orientation, color=defaultGray, alpha=0.1):
    &#34;&#34;&#34;
    Adds a vertical line, horizontal line, or band indicating the ideal value
    (or range of values) for the provided score.

    Args:
        ax (Axes): `Axes` object onto which the line&#39;s plotted.
        label (str): Label for the ideal score.
        placement (float,tuple): If plotting a line, a single value; if plotting
            a band, a tuple of (start, end) values.
        orientation (str): Indicates the direction of the line or band. Acceptable
            values are `&#34;horizontal&#34;` or `&#34;vertical&#34;`.
        color (str, optional): Color of the line or band. Defaults to `defaultGray`.
        alpha (float, optional): Opacity of the line or band. Defaults to `0.1`.
    &#34;&#34;&#34;
    orig_xlims = ax.get_xlim()
    orig_ylims = ax.get_ylim()

    # Warn the user and abort if the `placement` parameter isn&#39;t of the correct
    # type.
    if type(placement) not in {float, int, tuple}:
        raise TypeError(&#34;`placement` is not of correct type.&#34;)

    # If `placement` is a tuple, we draw a band.
    if type(placement) is tuple:
        if orientation == &#34;horizontal&#34;:
            xlims = orig_xlims
            ylims1 = [placement[0], placement[0]]
            ylims2 = [placement[1], placement[1]]
        elif orientation == &#34;vertical&#34;:
            xlims = placement
            ylims1 = [orig_ylims[0], orig_ylims[0]]
            ylims2 = [orig_ylims[1], orig_ylims[1]]
        
        ax.fill_between(xlims, ylims1, ylims2, color=color, alpha=alpha, label=label)
    # Otherwise, draw a line.
    else:
        alpha = alpha if alpha else 0.5
        idealprops = dict(color=color, alpha=alpha, label=label)

        if orientation == &#34;horizontal&#34;: ax.axhline(placement+0.5, **idealprops)
        else: ax.axvline(placement+0.5, **idealprops)

    # Set the original x- and y-axis limits, and plot a legend.
    ax.set_xlim(orig_xlims)
    ax.set_ylim(orig_ylims)
    ax.legend()

    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.multidimensional"><code class="name flex">
<span>def <span class="ident">multidimensional</span></span>(<span>x, y, hist, labels=['X values', 'Y values', 'Histogram values'], bin_width=1, limits=None, proposed_info={}, figsize=(12, 8), save={})</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a multidimensional figure, comparing two metrics as a scatterplot above
and one metric as a histogram, below. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object on which the histogram is plotted.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>list</code></dt>
<dd>Score on the x-axis of the scatterplot.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list</code></dt>
<dd>Score on the y-axis of the scatterplot.</dd>
<dt><strong><code>hist</code></strong> :&ensp;<code>list</code></dt>
<dd>Score to be plotted as a histogram below.</dd>
<dt><strong><code>limits</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>x, y, and histogram limits, if wanted.</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>,
<code>x</code>, <code>y</code>, <code>hist</code>; the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the
<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name in <code>names</code>, which corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th value in
<code>x</code>, <code>y</code>, and <code>hist</code>.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Figure size</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The scatterplot and histogram axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multidimensional(x, 
                     y, 
                     hist, 
                     labels=[&#34;X values&#34;, &#34;Y values&#34;, &#34;Histogram values&#34;],
                     bin_width=1,
                     limits=None, 
                     proposed_info={},
                     figsize=(12,8),
                     save={},
                     ):
    &#34;&#34;&#34;
    Plot a multidimensional figure, comparing two metrics as a scatterplot above
    and one metric as a histogram, below. 

    Args:
        ax (Axes): `Axes` object on which the histogram is plotted.
        x (list): Score on the x-axis of the scatterplot.
        y (list): Score on the y-axis of the scatterplot.
        hist (list): Score to be plotted as a histogram below.
        limits (list, optional): x, y, and histogram limits, if wanted.
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`, 
            `x`, `y`, `hist`; the \(i\)th color in `color` corresponds to the 
            \(i\)th name in `names`, which corresponds to the \(i\)th value in 
            `x`, `y`, and `hist`.
        figsize (tuple, optional): Figure size

    Returns:
        The scatterplot and histogram axes.
    &#34;&#34;&#34;
    _ = plt.subplots(figsize=figsize)
    gs = gridspec.GridSpec(2, 1, height_ratios=[2, 1])

    scatter_limits = limits[:2] if limits else set()
    scatter_labels = labels[:2]
    scatter_ax = plt.subplot(gs[0])
    scatter_ax = scatterplot(scatter_ax, 
                             x, 
                             y, 
                             labels=scatter_labels,
                             limits=scatter_limits, 
                             proposed_info=proposed_info,
                             )
    
    scores = {
        &#34;ensemble&#34;: hist,
        &#34;citizen&#34;: [],
        &#34;proposed&#34;: proposed_info[&#34;hist&#34;] if proposed_info else [],
    }
    hist_limits = limits[-1] if limits else set()
    # print(f&#34;limits is: {limits}, {hist_limits}&#34;)
    hist_label = labels[-1]
    hist_ax = plt.subplot(gs[1])
    hist_ax = histogram(hist_ax, 
                        scores, 
                        label=hist_label,
                        limits=hist_limits, 
                        proposed_info=proposed_info, 
                        bin_width=bin_width,
                       )
    hist_ax.get_yaxis().set_visible(False)
    hist_ax.spines[&#39;top&#39;].set_visible(False)
    hist_ax.spines[&#39;right&#39;].set_visible(False)
    hist_ax.spines[&#39;left&#39;].set_visible(False)

    if save:
        folder = save[&#39;folder&#39;]
        filename = save[&#39;filename&#39;]
        frame = save[&#39;frame&#39;]
        os.makedirs(f&#39;{folder}/{filename}&#39;, exist_ok=True)
        plt.savefig(f&#39;{folder}/{filename}/{filename}_{frame}.png&#39;, dpi=save[&#39;DPI&#39;], bbox_inches=&#39;tight&#39;)
        plt.close()
    return scatter_ax, hist_ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.purples"><code class="name flex">
<span>def <span class="ident">purples</span></span>(<span>n) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of colors based on the <code>Purples</code> Matplotlib/seaborn colormap.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of colors to generate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of RGB triples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purples(n) -&gt; list:
    &#34;&#34;&#34;
    Returns a list of colors based on the `Purples` Matplotlib/seaborn colormap.

    Args:
        n (int): Number of colors to generate.

    Returns:
        List of RGB triples.
    &#34;&#34;&#34;
    return list(sns.color_palette(&#34;Purples&#34;, as_cmap=False, n_colors=n))</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.redbluecmap"><code class="name flex">
<span>def <span class="ident">redbluecmap</span></span>(<span>n) ‑> List[Tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a red/white/blue color palette in <code>n</code> colors with white at the
<code>mid</code>th index.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of colors to generate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of RGB tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redbluecmap(n) -&gt; List[Tuple]:
    &#34;&#34;&#34;
    Generates a red/white/blue color palette in `n` colors with white at the
    `mid`th index.

    Args:
        n (int): The number of colors to generate.

    Returns:
        List of RGB tuples.
    &#34;&#34;&#34;
    midpoint = math.ceil(n/2)
    
    # To get the appropriately-toned blues and reds, we create a list of colors,
    # then select the first section of each color.
    blues = list(
        sns.color_palette(&#34;coolwarm&#34;, as_cmap=False, n_colors=n+2)
    )[:midpoint]
    reds = list(
        sns.color_palette(&#34;coolwarm&#34;, as_cmap=False, n_colors=n+2)
    )[-midpoint:]
    
    return list(reversed(reds)) + list(reversed(blues))</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.scatterplot"><code class="name flex">
<span>def <span class="ident">scatterplot</span></span>(<span>ax, x, y, labels=None, limits=set(), proposed_info={}, bins=None, axis_range=None) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a scatterplot comparing two scores, with the proposed plans'
scores as points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object on which the histogram is plotted.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>list</code></dt>
<dd>Score on the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list</code></dt>
<dd>score on the y-axis.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Strings for x- and y-axis labels.</dd>
<dt><strong><code>limits</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Axis limits (specify to force plot to extend to
these limits).</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>,
<code>x</code>, <code>y</code>; the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name
in <code>names</code>, which corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th value in <code>x</code> and <code>y</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Axes object on which the scatterplot is plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatterplot(ax, 
                x, 
                y, 
                labels=None, 
                limits=set(), 
                proposed_info={}, 
                bins=None, 
                axis_range=None) -&gt; Axes:
    r&#34;&#34;&#34;
    Plot a scatterplot comparing two scores, with the proposed plans&#39;
    scores as points.

    Args:
        ax (Axes): `Axes` object on which the histogram is plotted.
        x (list): Score on the x-axis.
        y (list): score on the y-axis.
        labels (list, optional): Strings for x- and y-axis labels.
        limits (tuple, optional): Axis limits (specify to force plot to extend to 
            these limits).
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`, 
            `x`, `y`; the \(i\)th color in `color` corresponds to the \(i\)th name 
            in `names`, which corresponds to the \(i\)th value in `x` and `y`.

    Returns:
        Axes object on which the scatterplot is plotted.
    &#34;&#34;&#34;
    if not bins:
        bins = [np.arange(int(min(x)), int(max(x)) + 1), np.arange(int(min(y)), int(max(y)) + 1)]
    h, xedges, yedges, image = ax.hist2d(x,
                                         y,
                                         bins=bins,
                                         cmap=&#39;Greys&#39;,
                                         range=axis_range,
                                         )

    ### Shift bins over by 0.5 to center labels in the middle of the bin.
    ### TODO: This only works for bins of width 1 — need to fix for general bid width.
    ax.set_xticks([x + 0.5 for x in xedges])
    ax.set_xticklabels(xedges)
    ax.set_yticks([y + 0.5 for y in yedges])
    ax.set_yticklabels(yedges)

    if proposed_info:
        for i in range(len(proposed_info[&#39;names&#39;])):
            x = proposed_info[&#39;x&#39;][i]
            y = proposed_info[&#39;y&#39;][i]
            ax.scatter(
                    x + 0.5,
                    y + 0.5,
                    label=f&#34;{proposed_info[&#39;names&#39;][i]} ({x}, {y})&#34;,
                    color=proposed_info[&#39;colors&#39;][i],
                    s=150,
                    edgecolor=&#39;black&#39;,
                   )
        ax.legend()

    if labels:
        ax.set_xlabel(labels[0], fontsize=24)
        ax.set_ylabel(labels[1], fontsize=24)
    if limits:
        ax.set_xlim(limits[0])
        ax.set_ylim(limits[1])
    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.sealevel"><code class="name flex">
<span>def <span class="ident">sealevel</span></span>(<span>ax, scores, num_districts, proposed_info, ticksize=12)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a sea level plot: Each plan is a line across our elections on the
x-axis, with Democratic vote share on the y-axis. The statewide Dem. vote
share (proportionality) is plotted as a thick blue line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object on which the sea level plot is plotted.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keys of each plan plus a <code>statewide</code> key for proportionality.
Each value is another dictionary, with keys for each election, values are the # seats.</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>;
the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name in <code>names</code>.</dd>
<dt><strong><code>ticksize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size for tick labels.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sealevel(ax, scores, num_districts, proposed_info, ticksize=12):
    &#34;&#34;&#34;
    Plot a sea level plot: Each plan is a line across our elections on the 
    x-axis, with Democratic vote share on the y-axis. The statewide Dem. vote
    share (proportionality) is plotted as a thick blue line.

    Args:
        ax (Axes): `Axes` object on which the sea level plot is plotted.
        scores (dict): Dictionary with keys of each plan plus a `statewide` key for proportionality.
            Each value is another dictionary, with keys for each election, values are the # seats.
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`;
            the \(i\)th color in `color` corresponds to the \(i\)th name in `names`.
        ticksize (float, optional): Font size for tick labels.
    &#34;&#34;&#34;
    assert &#34;statewide&#34; in scores
    elections = sort_elections(scores[&#34;statewide&#34;].keys())
    shares_by_plan = {plan:[] for plan in scores}
    for plan in scores:
        for election in elections:
            shares_by_plan[plan].append(scores[plan][election])

    ax.plot(shares_by_plan[&#39;statewide&#39;],
            marker=&#39;o&#39;,
            markersize=10,
            lw=5,
            label=&#34;Proportionality&#34;,
           )
    for i, plan in enumerate(proposed_info[&#39;names&#39;]):
        for j in range(len(shares_by_plan[plan])):
            jitter = random.uniform(-0.02, 0.02) if len(set([shares_by_plan[plan][j] for plan in shares_by_plan.keys()])) &gt; 1 else 0
            shares_by_plan[plan][j] = shares_by_plan[plan][j] + jitter
        ax.plot(shares_by_plan[plan],
                marker=&#39;o&#39;,
                linestyle=&#39;--&#39;,
                color=proposed_info[&#39;colors&#39;][i],
                label=plan,
               )
    ax.legend()
    if num_districts &lt;= 20:
        yticks = np.arange(0, 1 + 1/num_districts, 1/num_districts)
        yticklabels = [f&#34;{i}/{num_districts}&#34; for i in range(num_districts + 1)]
        ax.set_yticks(yticks)
        ax.set_yticklabels(yticklabels)
    ax.axhline(0.5, color=defaultGray, label=&#34;50%&#34;)
    ax.set_xticks(range(len(elections)))
    ax.set_xticklabels(elections, fontsize=ticksize)
    ax.set_ylim(-0.02, 1)


    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.violin"><code class="name flex">
<span>def <span class="ident">violin</span></span>(<span>ax, scores, xticklabels=None, labels=None, proposed_info={}, percentiles=(1, 99), rotation=0, ticksize=12, jitter=0.3333333333333333) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a violin plot, which takes <code>scores</code> — a dictionary where each value (corresponding to
an ensemble, citizens' ensemble, or proposed plans), will be a list of lists, where each
sublist will be its own violin. Proposed scores will be plotted as colored circles on
their respective violin. Color the violins conditioned on the kind of the scores
(ensemble or citizen), and trim each sublist to only the values between the percentiles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object on which the violins are plotted.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keys of <code>ensemble</code>, <code>citizen</code>, <code>proposed</code>
which map to lists of numerical scores.</dd>
<dt><strong><code>proposed_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with keys of <code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code>, <code>names</code>;
the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th color in <code>color</code> corresponds to the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th name in `names.</dd>
<dt><strong><code>percentiles</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Observations outside this range of
percentiles are ignored. Defaults to <code>(1, 99)</code>, such that observations
between the 1st and 99th percentiles (inclusive) are included, and
all others are ignored.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tick labels are rotated <code>rotation</code> degrees
<em>counterclockwise</em>.</dd>
<dt><strong><code>ticksize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size for tick labels.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>When there is more than one proposed plan,
adjust its detail points by a value drawn from <span><span class="MathJax_Preview">\mathcal U (-\epsilon,
\epsilon)</span><script type="math/tex">\mathcal U (-\epsilon,
\epsilon)</script></span> where <span><span class="MathJax_Preview">\epsilon = </span><script type="math/tex">\epsilon = </script></span> <code>jitter</code>.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>x- and y-axis labels, if desired.</dd>
<dt><strong><code>xticklabels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Labels for the violins, default to integers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Axes</code> object on which the violins are plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def violin(
        ax, scores, xticklabels=None, labels=None, proposed_info={}, percentiles=(1,99), rotation=0,
        ticksize=12, jitter=1/3
    ) -&gt; Axes:
    r&#34;&#34;&#34;
    Plot a violin plot, which takes `scores` — a dictionary where each value (corresponding to 
    an ensemble, citizens&#39; ensemble, or proposed plans), will be a list of lists, where each 
    sublist will be its own violin. Proposed scores will be plotted as colored circles on
    their respective violin. Color the violins conditioned on the kind of the scores
    (ensemble or citizen), and trim each sublist to only the values between the percentiles.

    Args:
        ax (Axes): `Axes` object on which the violins are plotted.
        scores (dict): Dictionary with keys of `ensemble`, `citizen`, `proposed`
            which map to lists of numerical scores.
        proposed_info (dict, optional): Dictionary with keys of `colors`, `names`;
            the \(i\)th color in `color` corresponds to the \(i\)th name in `names.
        percentiles (tuple, optional): Observations outside this range of
            percentiles are ignored. Defaults to `(1, 99)`, such that observations
            between the 1st and 99th percentiles (inclusive) are included, and
            all others are ignored.
        rotation (float, optional): Tick labels are rotated `rotation` degrees
            _counterclockwise_.
        ticksize (float, optional): Font size for tick labels.
        jitter (float, optional): When there is more than one proposed plan,
            adjust its detail points by a value drawn from \(\mathcal U (-\epsilon,
            \epsilon)\) where \(\epsilon = \) `jitter`.
        labels (list, optional): x- and y-axis labels, if desired.
        xticklabels (list, optional): Labels for the violins, default to integers.

    Returns:
        `Axes` object on which the violins are plotted.
    &#34;&#34;&#34;
    # Get all the scores into one list; pick a face color.
    ensemble = scores[&#34;ensemble&#34;] if scores[&#34;ensemble&#34;] else scores[&#34;citizen&#34;]
    facecolor = defaultGray if scores[&#34;ensemble&#34;] else citizenBlue

    # Initialize a list for winnowing scores.
    trimmed_scores = []

    # Pare each ensemble down to only the observations between the 1st and 99th
    # percentiles.
    for score_list in ensemble:
        low = np.percentile(ensemble, percentiles[0])
        high = np.percentile(ensemble, percentiles[1])
        # print(f&#34;Only including scores between [{low}, {high}]&#34;)
        trimmed_scores.append([s for s in score_list if s &gt;= low and s &lt;= high])

    # Plot violins.
    parts = ax.violinplot(trimmed_scores, showextrema=False)

    # For each of the violins, modify its visual properties; change the face color
    # to the specified face color, change its edge color to black, and set its
    # opacity to 1.
    for pc in parts[&#34;bodies&#34;]:
        pc.set_facecolor(facecolor)
        pc.set_edgecolor(&#34;black&#34;)
        pc.set_alpha(1)

    # Set xticks, xlabels, and x-axis limits.
    if not xticklabels:
        xticklabels = range(1, len(scores[&#39;ensemble&#39;]) + 1)
    ax.set_xticks(range(1, len(ensemble) + 1))
    ax.set_xticklabels(xticklabels, fontsize=ticksize, rotation=rotation)
    ax.set_xlim(0.5, len(ensemble) + 0.5)

    # Plot each proposed plan individually, adjusting its detail points by
    # a value drawn from the uniform distribution of specified width centered on
    # the index of the violin.
    if scores[&#34;proposed&#34;]:
        for violin in range(len(scores[&#34;proposed&#34;])):
            for plan, score in enumerate(scores[&#34;proposed&#34;][violin]):
                # Horizontally jitter proposed scores if there are multiple scores
                # at the same height.
                jitter_val = random.uniform(-jitter, jitter) if scores[&#34;proposed&#34;][violin].count(score) &gt; 1 else 0
                ax.scatter(
                    violin + 1 + jitter_val,
                    score,
                    color=districtr(plan+1).pop(),
                    edgecolor=&#39;black&#39;,
                    s=100,
                    alpha=0.9,
                    label=proposed_info[&#34;names&#34;][plan] if violin == 0 else None,
                )
        ax.legend()
        ax.grid(axis=&#39;x&#39;)

    if labels:
        ax.set_xlabel(labels[0], fontsize=24)
        ax.set_ylabel(labels[1], fontsize=24)
    
    return ax</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="evaltools" href="https://github.com/mggg/plan-evaluation-processing">
<style>
header > h1 { display: none; }
img.resize {
max-width: 80%;
max-height: 80%;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
</style>
<img class="resize" src="https://mggg.org/assets/logo.svg" alt="MGGG Logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="evaltools" href="../index.html">evaltools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="evaltools.plotting.annotation" href="annotation.html">evaltools.plotting.annotation</a></code></li>
<li><code><a title="evaltools.plotting.colors" href="colors.html">evaltools.plotting.colors</a></code></li>
<li><code><a title="evaltools.plotting.gifs" href="gifs.html">evaltools.plotting.gifs</a></code></li>
<li><code><a title="evaltools.plotting.utils" href="utils.html">evaltools.plotting.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="evaltools.plotting.arrow" href="#evaltools.plotting.arrow">arrow</a></code></li>
<li><code><a title="evaltools.plotting.bins" href="#evaltools.plotting.bins">bins</a></code></li>
<li><code><a title="evaltools.plotting.boxplot" href="#evaltools.plotting.boxplot">boxplot</a></code></li>
<li><code><a title="evaltools.plotting.choropleth" href="#evaltools.plotting.choropleth">choropleth</a></code></li>
<li><code><a title="evaltools.plotting.districtnumbers" href="#evaltools.plotting.districtnumbers">districtnumbers</a></code></li>
<li><code><a title="evaltools.plotting.districtr" href="#evaltools.plotting.districtr">districtr</a></code></li>
<li><code><a title="evaltools.plotting.drawgraph" href="#evaltools.plotting.drawgraph">drawgraph</a></code></li>
<li><code><a title="evaltools.plotting.drawplan" href="#evaltools.plotting.drawplan">drawplan</a></code></li>
<li><code><a title="evaltools.plotting.flare" href="#evaltools.plotting.flare">flare</a></code></li>
<li><code><a title="evaltools.plotting.gif_multidimensional" href="#evaltools.plotting.gif_multidimensional">gif_multidimensional</a></code></li>
<li><code><a title="evaltools.plotting.histogram" href="#evaltools.plotting.histogram">histogram</a></code></li>
<li><code><a title="evaltools.plotting.ideal" href="#evaltools.plotting.ideal">ideal</a></code></li>
<li><code><a title="evaltools.plotting.multidimensional" href="#evaltools.plotting.multidimensional">multidimensional</a></code></li>
<li><code><a title="evaltools.plotting.purples" href="#evaltools.plotting.purples">purples</a></code></li>
<li><code><a title="evaltools.plotting.redbluecmap" href="#evaltools.plotting.redbluecmap">redbluecmap</a></code></li>
<li><code><a title="evaltools.plotting.scatterplot" href="#evaltools.plotting.scatterplot">scatterplot</a></code></li>
<li><code><a title="evaltools.plotting.sealevel" href="#evaltools.plotting.sealevel">sealevel</a></code></li>
<li><code><a title="evaltools.plotting.violin" href="#evaltools.plotting.violin">violin</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>