<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools.plotting.annotation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>evaltools.plotting.annotation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from matplotlib.axes import Axes
from .colors import defaultGray

def arrow(
    ax, text, orientation=&#34;horizontal&#34;, color=defaultGray, padding=0.1
    ) -&gt; Axes:
    &#34;&#34;&#34;
    For some partisan metrics, we want to draw an arrow showing where the POV-party&#39;s
    advantage is. Depending on the orientation of the scores (histograms have
    scores arranged horizontally, violinplots have scores arranged vertically),
    we either place the arrow at the bottom left, pointing rightward, or in the
    middle of the y-axis, pointing up.

    Args:
        ax (Axes): `Axes` object onto which the arrow&#39;s plotted.
        text (str): String plotted on top of the arrow.
        orientation (str, optional): Direction the arrow&#39;s pointing; acceptable
            values are `&#34;horizontal&#34;` and `&#34;vertical&#34;`. Defaults to `&#34;horizontal&#34;`.
        color (str, optional): Color of the arrow.
        padding (float, optional): Spacing between the arrow and its axis. Defaults
            to `0.1`.
    &#34;&#34;&#34;

    if orientation == &#34;horizontal&#34;:
        x = ax.get_xlim()[0]
        y = ax.get_ylim()[0] - padding*ax.get_ylim()[1]
        horizontal_align = &#34;left&#34;
        rotation = 0
    elif orientation == &#34;vertical&#34;:
        x = ax.get_xlim()[0] -  padding*(sum(map(lambda x: abs(x), ax.get_xlim())))
        y = sum(ax.get_ylim())/2
        horizontal_align = &#34;center&#34;
        rotation = 90
    
    ax.text(x, y,
            text,
            ha=horizontal_align,
            va=&#34;center&#34;,
            color=&#34;white&#34;,
            rotation=rotation,
            size=10,
            bbox=dict(
                boxstyle=&#34;rarrow,pad=0.3&#34;,
                fc=color,
                alpha=1,
                ec=&#34;black&#34;,
                )
            )
    return ax

def ideal(ax, label, placement, orientation, color=defaultGray, alpha=0.1):
    &#34;&#34;&#34;
    Adds a vertical line, horizontal line, or band indicating the ideal value
    (or range of values) for the provided score.

    Args:
        ax (Axes): `Axes` object onto which the line&#39;s plotted.
        label (str): Label for the ideal score.
        placement (float,tuple): If plotting a line, a single value; if plotting
            a band, a tuple of (start, end) values.
        orientation (str): Indicates the direction of the line or band. Acceptable
            values are `&#34;horizontal&#34;` or `&#34;vertical&#34;`.
        color (str, optional): Color of the line or band. Defaults to `defaultGray`.
        alpha (float, optional): Opacity of the line or band. Defaults to `0.1`.
    &#34;&#34;&#34;
    orig_xlims = ax.get_xlim()
    orig_ylims = ax.get_ylim()

    # Warn the user and abort if the `placement` parameter isn&#39;t of the correct
    # type.
    if type(placement) not in {float, int, tuple}:
        raise TypeError(&#34;`placement` is not of correct type.&#34;)

    # If `placement` is a tuple, we draw a band.
    if type(placement) is tuple:
        if orientation == &#34;horizontal&#34;:
            xlims = orig_xlims
            ylims1 = [placement[0], placement[0]]
            ylims2 = [placement[1], placement[1]]
        elif orientation == &#34;vertical&#34;:
            xlims = placement
            ylims1 = [orig_ylims[0], orig_ylims[0]]
            ylims2 = [orig_ylims[1], orig_ylims[1]]
        
        ax.fill_between(xlims, ylims1, ylims2, color=color, alpha=alpha, label=label)
    # Otherwise, draw a line.
    else:
        alpha = alpha if alpha else 0.5
        idealprops = dict(color=color, alpha=alpha, label=label)

        if orientation == &#34;horizontal&#34;: ax.axhline(placement+0.5, **idealprops)
        else: ax.axvline(placement+0.5, **idealprops)

    # Set the original x- and y-axis limits, and plot a legend.
    ax.set_xlim(orig_xlims)
    ax.set_ylim(orig_ylims)
    ax.legend()

    return ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.plotting.annotation.arrow"><code class="name flex">
<span>def <span class="ident">arrow</span></span>(<span>ax, text, orientation='horizontal', color='#5c676f', padding=0.1) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>For some partisan metrics, we want to draw an arrow showing where the POV-party's
advantage is. Depending on the orientation of the scores (histograms have
scores arranged horizontally, violinplots have scores arranged vertically),
we either place the arrow at the bottom left, pointing rightward, or in the
middle of the y-axis, pointing up.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object onto which the arrow's plotted.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>String plotted on top of the arrow.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Direction the arrow's pointing; acceptable
values are <code>"horizontal"</code> and <code>"vertical"</code>. Defaults to <code>"horizontal"</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color of the arrow.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Spacing between the arrow and its axis. Defaults
to <code>0.1</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow(
    ax, text, orientation=&#34;horizontal&#34;, color=defaultGray, padding=0.1
    ) -&gt; Axes:
    &#34;&#34;&#34;
    For some partisan metrics, we want to draw an arrow showing where the POV-party&#39;s
    advantage is. Depending on the orientation of the scores (histograms have
    scores arranged horizontally, violinplots have scores arranged vertically),
    we either place the arrow at the bottom left, pointing rightward, or in the
    middle of the y-axis, pointing up.

    Args:
        ax (Axes): `Axes` object onto which the arrow&#39;s plotted.
        text (str): String plotted on top of the arrow.
        orientation (str, optional): Direction the arrow&#39;s pointing; acceptable
            values are `&#34;horizontal&#34;` and `&#34;vertical&#34;`. Defaults to `&#34;horizontal&#34;`.
        color (str, optional): Color of the arrow.
        padding (float, optional): Spacing between the arrow and its axis. Defaults
            to `0.1`.
    &#34;&#34;&#34;

    if orientation == &#34;horizontal&#34;:
        x = ax.get_xlim()[0]
        y = ax.get_ylim()[0] - padding*ax.get_ylim()[1]
        horizontal_align = &#34;left&#34;
        rotation = 0
    elif orientation == &#34;vertical&#34;:
        x = ax.get_xlim()[0] -  padding*(sum(map(lambda x: abs(x), ax.get_xlim())))
        y = sum(ax.get_ylim())/2
        horizontal_align = &#34;center&#34;
        rotation = 90
    
    ax.text(x, y,
            text,
            ha=horizontal_align,
            va=&#34;center&#34;,
            color=&#34;white&#34;,
            rotation=rotation,
            size=10,
            bbox=dict(
                boxstyle=&#34;rarrow,pad=0.3&#34;,
                fc=color,
                alpha=1,
                ec=&#34;black&#34;,
                )
            )
    return ax</code></pre>
</details>
</dd>
<dt id="evaltools.plotting.annotation.ideal"><code class="name flex">
<span>def <span class="ident">ideal</span></span>(<span>ax, label, placement, orientation, color='#5c676f', alpha=0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a vertical line, horizontal line, or band indicating the ideal value
(or range of values) for the provided score.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axes</code></dt>
<dd><code>Axes</code> object onto which the line's plotted.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>Label for the ideal score.</dd>
<dt><strong><code>placement</code></strong> :&ensp;<code>float,tuple</code></dt>
<dd>If plotting a line, a single value; if plotting
a band, a tuple of (start, end) values.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>Indicates the direction of the line or band. Acceptable
values are <code>"horizontal"</code> or <code>"vertical"</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color of the line or band. Defaults to <code>defaultGray</code>.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Opacity of the line or band. Defaults to <code>0.1</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ideal(ax, label, placement, orientation, color=defaultGray, alpha=0.1):
    &#34;&#34;&#34;
    Adds a vertical line, horizontal line, or band indicating the ideal value
    (or range of values) for the provided score.

    Args:
        ax (Axes): `Axes` object onto which the line&#39;s plotted.
        label (str): Label for the ideal score.
        placement (float,tuple): If plotting a line, a single value; if plotting
            a band, a tuple of (start, end) values.
        orientation (str): Indicates the direction of the line or band. Acceptable
            values are `&#34;horizontal&#34;` or `&#34;vertical&#34;`.
        color (str, optional): Color of the line or band. Defaults to `defaultGray`.
        alpha (float, optional): Opacity of the line or band. Defaults to `0.1`.
    &#34;&#34;&#34;
    orig_xlims = ax.get_xlim()
    orig_ylims = ax.get_ylim()

    # Warn the user and abort if the `placement` parameter isn&#39;t of the correct
    # type.
    if type(placement) not in {float, int, tuple}:
        raise TypeError(&#34;`placement` is not of correct type.&#34;)

    # If `placement` is a tuple, we draw a band.
    if type(placement) is tuple:
        if orientation == &#34;horizontal&#34;:
            xlims = orig_xlims
            ylims1 = [placement[0], placement[0]]
            ylims2 = [placement[1], placement[1]]
        elif orientation == &#34;vertical&#34;:
            xlims = placement
            ylims1 = [orig_ylims[0], orig_ylims[0]]
            ylims2 = [orig_ylims[1], orig_ylims[1]]
        
        ax.fill_between(xlims, ylims1, ylims2, color=color, alpha=alpha, label=label)
    # Otherwise, draw a line.
    else:
        alpha = alpha if alpha else 0.5
        idealprops = dict(color=color, alpha=alpha, label=label)

        if orientation == &#34;horizontal&#34;: ax.axhline(placement+0.5, **idealprops)
        else: ax.axvline(placement+0.5, **idealprops)

    # Set the original x- and y-axis limits, and plot a legend.
    ax.set_xlim(orig_xlims)
    ax.set_ylim(orig_ylims)
    ax.legend()

    return ax</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="evaltools" href="https://github.com/mggg/plan-evaluation-processing">
<style>
header > h1 { display: none; }
img.resize {
max-width: 80%;
max-height: 80%;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
p {
text-align: justify;
}
</style>
<img class="resize" src="https://mggg.org/assets/logo.svg" alt="MGGG Logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="evaltools.plotting" href="index.html">evaltools.plotting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="evaltools.plotting.annotation.arrow" href="#evaltools.plotting.annotation.arrow">arrow</a></code></li>
<li><code><a title="evaltools.plotting.annotation.ideal" href="#evaltools.plotting.annotation.ideal">ideal</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>