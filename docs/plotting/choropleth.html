<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools.plotting.choropleth API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>evaltools.plotting.choropleth</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.axes import Axes
import numpy as np
from math import ceil

from .colors import overlays as overlaycolors
from .districtnumbers import districtnumbers


def choropleth(
        geometries, districts=None, assignment=None, demographic=&#34;BVAP&#34;,
        overlays=[], cmap=&#34;Purples&#34;, cbartitle=None, numbers=True, lw=1/8
    ) -&gt; Axes:
    &#34;&#34;&#34;
    Visualization of population shares or totals in a state&#39;s map.
    
    Args:
        geometries (GeoDataFrame): Base geometries for the state. Population
            shares or totals will be drawn at this level (i.e. statistics are
            reported at this base geometric level).
        districts (GeoDataFrame, optional): Geometries for the districting plan.
            Assumes one geometry per district. 
        assignment (str, optional): Required argument when `districts` are
            provided. Column of `districts` which defines the districing plan. 
        demographic (str, optional): The string representing the demographic to
            be shown on the map. The string should specify a column in `geometries`.
            Note that if a demographic share is desired for plotting, the share
            should be added to the GeoDataFrame prior to calling this function. 
        overlays (list, optional): A list of GeoDataFrames desired to be overlaid on
            the map. Some options would include overlaying district assignments,
            blocks, VTDs, or counties. The first set of geometries in the list
            will be overlaid in the lightest color, and last will be overlaid in
            the darkest color.
            cmap (string, optional): Defines which colormap to use. Defaults to
            matplotlib&#39;s `Purples` colormap.
        cbartitle (string, optional): Title for the colorbar. Defaults to
            `demographic`.
        numbers (bool, optional): If `True`, plot district names (as defined by
            `assignment`) at districts&#39; centroids. May only be `True` when
            `districts` is not `None`.
        lw (float, optional): The base geometries&#39; line widths.

    Returns:
        A matplotlib `Axes` object visualizing a choropleth map with the provided
        overlays.
    &#34;&#34;&#34;
    # Get the figure and base axis sizes.
    fig, base = plt.subplots(1, 1, figsize=(10,10))
    
    # Dissolve the geometries to get the boundary of their union.
    boundary = geometries.dissolve()
    
    # Get the title for the colorbar.
    if cbartitle is None: cbartitle = demographic
    
    # Create an empty list to store ticks; if it&#39;s a proportion being plotted,
    # automatically create ticks and percentage labels for the color bar.
    colorbar_ticks = []
    if max(geometries[demographic]) &lt;= 1: 
        colorbar_ticks = np.linspace(0, 1, 11)
        colorbar_labels = [f&#34;{tick*100}%&#34; for tick in colorbar_ticks]
        vmin = 0
        vmax = 1        
        bounds = colorbar_ticks * 100 
    else:
        # Decide the tick interval based on the average population (over geometries
        # with nonzero population).
        colorbar_center = ceil(np.mean(geometries[demographic][geometries[demographic] &gt; 0])/10)*10
        colorbar_ticks = [i * 10 + 1 if i &gt; 0 else i for i in range(int(colorbar_center/10))]
        max_pop = max(geometries[demographic])

        # Based on population conditions, decides the number of ticks.
        if max_pop &gt; 200 and colorbar_center &lt; 100: 
            colorbar_ticks.extend([i*100 + 1 for i in range(1, 3)])
        elif max_pop &gt; 500 and colorbar_center &gt; 100: 
            colorbar_ticks.extend([i*100 + 1 for i in range(round(colorbar_center/100)+1, 6)])
        else:
            colorbar_ticks.extend([i*100 + 1 for i in range(int(round(max_pop,-1)/10))])

        # Extend the color bar to capture the maximum population value.
        colorbar_ticks.append(max_pop)    
        colorbar_ticks = np.array(colorbar_ticks)

        # Create labels based on the population values.
        colorbar_labels = [f&#34;{colorbar_ticks[i]}-{colorbar_ticks[i+1]}&#34; for i in range(len(colorbar_ticks)-2)]
        colorbar_labels.extend([f&#34;{colorbar_ticks[-2]}+&#34;, &#34;&#34;])

        # Set the plot bounds based on population values and set the normalizer
        # for the color map.
        bounds = colorbar_ticks
        vmin = 0 
        vmax = max_pop
    
    # Set the color map, based on user preference or default (purples).
    colorbarmap = plt.cm.get_cmap(cmap, len(colorbar_ticks))
    norm = mpl.colors.BoundaryNorm(bounds, colorbarmap.N)
        
    # Plot geometries!
    geometries.plot(
        column=demographic, 
        cmap=cmap,
        edgecolor=&#34;lightgray&#34;, 
        linewidth=lw,
        vmin=vmin, 
        vmax=vmax,
        ax=base
    )

    # Create and plot the colorbar on the right side of the figure.
    cbar = fig.colorbar(
        plt.cm.ScalarMappable(cmap=colorbarmap, norm=norm), shrink=0.5,
        location=&#34;right&#34;,  ax=base, ticks=bounds
    )
    cbar.ax.set_yticklabels(colorbar_labels)
    cbar.ax.set_ylabel(cbartitle)
    cbar.ax.yaxis.set_label_position(&#34;left&#34;)
    
    # Plot each of the overlays, adjusting CRSes and applying colors as we go.
    for idx, geom in enumerate(overlays):
        geom = geom.to_crs(geometries.crs)
        geom.boundary.plot(edgecolor=overlaycolors[-(idx+1)], linewidth = 1/4, ax =base)
    
    # If district geometries are provided, plot them as well.
    if districts is not None:
        districts.boundary.plot( 
            edgecolor=&#34;black&#34;,
            linewidth=3/2, 
            ax=base
        )

    # If district numbers are to be plotted, plot those too!
    if numbers: base = districtnumbers( base, districts, assignment=assignment)
    
    # Plot the boundary and set its color to black.
    boundary.boundary.plot(color=&#34;black&#34;, ax=base)

    # Turn plot vertical/horizontal axes off and return base Axes.
    base.set_axis_off()
    return base</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.plotting.choropleth.choropleth"><code class="name flex">
<span>def <span class="ident">choropleth</span></span>(<span>geometries, districts=None, assignment=None, demographic='BVAP', overlays=[], cmap='Purples', cbartitle=None, numbers=True, lw=0.125) ‑> matplotlib.axes._axes.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Visualization of population shares or totals in a state's map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometries</code></strong> :&ensp;<code>GeoDataFrame</code></dt>
<dd>Base geometries for the state. Population
shares or totals will be drawn at this level (i.e. statistics are
reported at this base geometric level).</dd>
<dt><strong><code>districts</code></strong> :&ensp;<code>GeoDataFrame</code>, optional</dt>
<dd>Geometries for the districting plan.
Assumes one geometry per district. </dd>
<dt><strong><code>assignment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Required argument when <code>districts</code> are
provided. Column of <code>districts</code> which defines the districing plan. </dd>
<dt><strong><code>demographic</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The string representing the demographic to
be shown on the map. The string should specify a column in <code>geometries</code>.
Note that if a demographic share is desired for plotting, the share
should be added to the GeoDataFrame prior to calling this function. </dd>
<dt><strong><code>overlays</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of GeoDataFrames desired to be overlaid on
the map. Some options would include overlaying district assignments,
blocks, VTDs, or counties. The first set of geometries in the list
will be overlaid in the lightest color, and last will be overlaid in
the darkest color.
cmap (string, optional): Defines which colormap to use. Defaults to
matplotlib's <code>Purples</code> colormap.</dd>
<dt><strong><code>cbartitle</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Title for the colorbar. Defaults to
<code>demographic</code>.</dd>
<dt><strong><code>numbers</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, plot district names (as defined by
<code>assignment</code>) at districts' centroids. May only be <code>True</code> when
<code>districts</code> is not <code>None</code>.</dd>
<dt><strong><code>lw</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The base geometries' line widths.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A matplotlib <code>Axes</code> object visualizing a choropleth map with the provided
overlays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choropleth(
        geometries, districts=None, assignment=None, demographic=&#34;BVAP&#34;,
        overlays=[], cmap=&#34;Purples&#34;, cbartitle=None, numbers=True, lw=1/8
    ) -&gt; Axes:
    &#34;&#34;&#34;
    Visualization of population shares or totals in a state&#39;s map.
    
    Args:
        geometries (GeoDataFrame): Base geometries for the state. Population
            shares or totals will be drawn at this level (i.e. statistics are
            reported at this base geometric level).
        districts (GeoDataFrame, optional): Geometries for the districting plan.
            Assumes one geometry per district. 
        assignment (str, optional): Required argument when `districts` are
            provided. Column of `districts` which defines the districing plan. 
        demographic (str, optional): The string representing the demographic to
            be shown on the map. The string should specify a column in `geometries`.
            Note that if a demographic share is desired for plotting, the share
            should be added to the GeoDataFrame prior to calling this function. 
        overlays (list, optional): A list of GeoDataFrames desired to be overlaid on
            the map. Some options would include overlaying district assignments,
            blocks, VTDs, or counties. The first set of geometries in the list
            will be overlaid in the lightest color, and last will be overlaid in
            the darkest color.
            cmap (string, optional): Defines which colormap to use. Defaults to
            matplotlib&#39;s `Purples` colormap.
        cbartitle (string, optional): Title for the colorbar. Defaults to
            `demographic`.
        numbers (bool, optional): If `True`, plot district names (as defined by
            `assignment`) at districts&#39; centroids. May only be `True` when
            `districts` is not `None`.
        lw (float, optional): The base geometries&#39; line widths.

    Returns:
        A matplotlib `Axes` object visualizing a choropleth map with the provided
        overlays.
    &#34;&#34;&#34;
    # Get the figure and base axis sizes.
    fig, base = plt.subplots(1, 1, figsize=(10,10))
    
    # Dissolve the geometries to get the boundary of their union.
    boundary = geometries.dissolve()
    
    # Get the title for the colorbar.
    if cbartitle is None: cbartitle = demographic
    
    # Create an empty list to store ticks; if it&#39;s a proportion being plotted,
    # automatically create ticks and percentage labels for the color bar.
    colorbar_ticks = []
    if max(geometries[demographic]) &lt;= 1: 
        colorbar_ticks = np.linspace(0, 1, 11)
        colorbar_labels = [f&#34;{tick*100}%&#34; for tick in colorbar_ticks]
        vmin = 0
        vmax = 1        
        bounds = colorbar_ticks * 100 
    else:
        # Decide the tick interval based on the average population (over geometries
        # with nonzero population).
        colorbar_center = ceil(np.mean(geometries[demographic][geometries[demographic] &gt; 0])/10)*10
        colorbar_ticks = [i * 10 + 1 if i &gt; 0 else i for i in range(int(colorbar_center/10))]
        max_pop = max(geometries[demographic])

        # Based on population conditions, decides the number of ticks.
        if max_pop &gt; 200 and colorbar_center &lt; 100: 
            colorbar_ticks.extend([i*100 + 1 for i in range(1, 3)])
        elif max_pop &gt; 500 and colorbar_center &gt; 100: 
            colorbar_ticks.extend([i*100 + 1 for i in range(round(colorbar_center/100)+1, 6)])
        else:
            colorbar_ticks.extend([i*100 + 1 for i in range(int(round(max_pop,-1)/10))])

        # Extend the color bar to capture the maximum population value.
        colorbar_ticks.append(max_pop)    
        colorbar_ticks = np.array(colorbar_ticks)

        # Create labels based on the population values.
        colorbar_labels = [f&#34;{colorbar_ticks[i]}-{colorbar_ticks[i+1]}&#34; for i in range(len(colorbar_ticks)-2)]
        colorbar_labels.extend([f&#34;{colorbar_ticks[-2]}+&#34;, &#34;&#34;])

        # Set the plot bounds based on population values and set the normalizer
        # for the color map.
        bounds = colorbar_ticks
        vmin = 0 
        vmax = max_pop
    
    # Set the color map, based on user preference or default (purples).
    colorbarmap = plt.cm.get_cmap(cmap, len(colorbar_ticks))
    norm = mpl.colors.BoundaryNorm(bounds, colorbarmap.N)
        
    # Plot geometries!
    geometries.plot(
        column=demographic, 
        cmap=cmap,
        edgecolor=&#34;lightgray&#34;, 
        linewidth=lw,
        vmin=vmin, 
        vmax=vmax,
        ax=base
    )

    # Create and plot the colorbar on the right side of the figure.
    cbar = fig.colorbar(
        plt.cm.ScalarMappable(cmap=colorbarmap, norm=norm), shrink=0.5,
        location=&#34;right&#34;,  ax=base, ticks=bounds
    )
    cbar.ax.set_yticklabels(colorbar_labels)
    cbar.ax.set_ylabel(cbartitle)
    cbar.ax.yaxis.set_label_position(&#34;left&#34;)
    
    # Plot each of the overlays, adjusting CRSes and applying colors as we go.
    for idx, geom in enumerate(overlays):
        geom = geom.to_crs(geometries.crs)
        geom.boundary.plot(edgecolor=overlaycolors[-(idx+1)], linewidth = 1/4, ax =base)
    
    # If district geometries are provided, plot them as well.
    if districts is not None:
        districts.boundary.plot( 
            edgecolor=&#34;black&#34;,
            linewidth=3/2, 
            ax=base
        )

    # If district numbers are to be plotted, plot those too!
    if numbers: base = districtnumbers( base, districts, assignment=assignment)
    
    # Plot the boundary and set its color to black.
    boundary.boundary.plot(color=&#34;black&#34;, ax=base)

    # Turn plot vertical/horizontal axes off and return base Axes.
    base.set_axis_off()
    return base</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="evaltools" href="https://github.com/mggg/plan-evaluation-processing">
<style>
header > h1 { display: none; }
img.resize {
max-width: 80%;
max-height: 80%;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
</style>
<img class="resize" src="https://mggg.org/assets/logo.svg" alt="MGGG Logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="evaltools.plotting" href="index.html">evaltools.plotting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="evaltools.plotting.choropleth.choropleth" href="#evaltools.plotting.choropleth.choropleth">choropleth</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>