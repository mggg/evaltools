<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools.scores API documentation</title>
<meta name="description" content="Basic functionality for evaluating districting plans." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>evaltools.scores</code></h1>
</header>
<section id="section-intro">
<p>Basic functionality for evaluating districting plans.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Basic functionality for evaluating districting plans.
&#34;&#34;&#34;

from .splits import splits, pieces
from .population import deviations, unassigned_population
from .contiguity import unassigned_units, contiguous
from .reock import reock

__all__ = [
    &#34;splits&#34;,
    &#34;pieces&#34;,
    &#34;deviations&#34;,
    &#34;unassigned_population&#34;,
    &#34;unassigned_units&#34;,
    &#34;contiguous&#34;,
    &#34;reock&#34;
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="evaltools.scores.contiguity" href="contiguity.html">evaltools.scores.contiguity</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.scores.population" href="population.html">evaltools.scores.population</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.scores.contiguous"><code class="name flex">
<span>def <span class="ident">contiguous</span></span>(<span>P: gerrychain.partition.partition.Partition) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the districting plan defined by the partition is
contiguous.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the districting plan defined by the partition is contiguous.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contiguous(P: gerrychain.Partition) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether the districting plan defined by the partition is
    contiguous.

    Args:
        P (Partition): GerryChain Partition object.

    Returns:
        Whether the districting plan defined by the partition is contiguous.
    &#34;&#34;&#34;
    return ctgs(P)</code></pre>
</details>
</dd>
<dt id="evaltools.scores.deviations"><code class="name flex">
<span>def <span class="ident">deviations</span></span>(<span>P, popcolumn) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the districting plan's population deviation percentages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
<dt><strong><code>popcolumn</code></strong> :&ensp;<code>str</code></dt>
<dd>Column for tallying the desired population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary which maps district names to population deviation percentages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deviations(P, popcolumn) -&gt; dict:
    &#34;&#34;&#34;
    Determines the districting plan&#39;s population deviation percentages.
    
    Args:
        P (Partition): GerryChain Partition object.
        popcolumn (str): Column for tallying the desired population.

    Returns:
        A dictionary which maps district names to population deviation percentages.
    &#34;&#34;&#34;
    # Create the partition and the corresponding updater.
    poptally = Tally(popcolumn, alias=popcolumn)
    P.updaters = { popcolumn: poptally }

    # Return a dictionary that maps district names to population deviation
    # percentages.
    return deviation(P, attribute=popcolumn)</code></pre>
</details>
</dd>
<dt id="evaltools.scores.pieces"><code class="name flex">
<span>def <span class="ident">pieces</span></span>(<span>P, units, names=False) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the number of "unit pieces" produced by the plan. For example,
consider a state with 100 counties. Suppose that one county is split twice,
and another once. Then, there are 3 + 2 = 5 "pieces," disregarding the
counties kept whole.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>list</code></dt>
<dd>List of data columns; each assigns a vertex to a unit.
Generally, these units are counties, VTDs, precincts, etc.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether we return the identifiers of the things
being pieced.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping column names to the number of pieces <em>or</em> the number
of things being split.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pieces(P, units, names=False) -&gt; dict:
    &#34;&#34;&#34;
    Determines the number of &#34;unit pieces&#34; produced by the plan. For example,
    consider a state with 100 counties. Suppose that one county is split twice,
    and another once. Then, there are 3 + 2 = 5 &#34;pieces,&#34; disregarding the
    counties kept whole.
    
    Bear in mind that this calculates the number of _unit splits_, not the number
    of _units split_: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county 
    being split).

    Args:
        P (Partition): GerryChain Partition object.
        units (list): List of data columns; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        names (bool, optional): Whether we return the identifiers of the things
            being pieced.

    Returns:
        A dictionary mapping column names to the number of pieces *or* the number
        of things being split.
    &#34;&#34;&#34;
    if not names:
        geometrypieces = {
            unit: sum(
                len(split.contains)
                for split in county_splits(&#34;&#34;, unit)(P).values()
                if len(split.contains) &gt; 1
            )
            for unit in units
        }
    else:
        geometrypieces = {
            unit: [
                identifier
                for identifier, split in county_splits(&#34;&#34;, unit)(P).items()
                if len(split.contains) &gt; 1
            ]
            for unit in units
        }

    return geometrypieces</code></pre>
</details>
</dd>
<dt id="evaltools.scores.reock"><code class="name flex">
<span>def <span class="ident">reock</span></span>(<span>geodata: Union[geopandas.geodataframe.GeoDataFrame, gerrychain.graph.graph.Graph]) ‑> Callable[[gerrychain.partition.geographic.GeographicPartition], Dict[Any, float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a Reock score function specialized to <code>geodata</code>.</p>
<p>The Reock score of a district is its area defined by the area of its
minimum enclosing circle. Computing the area of this circle is nontrivial,
and the Reock score is distinct from other popular compactness scores
(cut edges, Polsby-Popper) in its reliance on full district geometries
(rather than district areas and perimeters, which can be computed
efficiently from unit-level statistics).</p>
<p>We precompute convex hulls of all geometries in <code>geodata</code> and
build an index. The resulting score function uses this index for
fast geometric computations; the function can only be used with
dual graphs derived from <code>geodata</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geodata</code></strong> :&ensp;<code>gpd.GeoDataFrame, Graph</code></dt>
<dd>Geographical data to precompute
geometries from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A per-district Reock score updater specialized to <code>geodata</code>.
</br></p>
<p>Below, we provide short proofs of correctness for the optimizations utilized
in this updater. First, we show that the convex hull of a union of tiled
geometries is the same as the convex hull of the union of the geometries' convex
hulls. Next, we show that the convex hull of only the exterior tiled geometries
of a given polygon is the same as the convex hull of all the geometries.
Lastly, we show that the minimum bounding circle of a given polygon is the
same as the minimum bounding circle of the polygon's convex hull.</p>
<div class="proof">
<p>
<i>Proof (equality of convex hulls of unions).</i> Let \(X\) be a simple
polygon in the plane; let \(S\) be a set of simple polygons \(s_1,
\dots, s_n\) which tile \(X\) such that \(\cup S = X\), and \(S^*\)
a set of polygons where \(s^*_i = \text{Hull}(s_i)\). Denote the
union of polygons in \(S^*\) by \(X^*\), so
that \(\cup S^* = X^*\).
Let \(V\) be the vertices which define \(\text{Hull}(X)\), and \(V^*\)
the vertices which define
\(\text{Hull}(X^*)\). We wish to show that
\(V = V^*\).
</p>
<p>
(\(\supseteq\)) Each vertex of \(s^*_i\) is a vertex of \(s_i\).
Consequently, the vertices of \(X^*\) are a subset of \(X\)'s
vertices, implying that \(\text{Hull}(X^*)\)'s vertices are a subset
of \(\text{Hull}(X)\)'s. As such, \(V \supseteq V^*\).
</p>
<p>
(\(\subseteq\)) Suppose, for the sake of contradiction, that \(V\)
contains a vertex \(v\) that is <i>not</i> contained in \(V^*\),
and that \(v\) is a vertex of the polygon \(s_i\). If \(v\) is not
in \(V^*\), then it can't be on the hull of \(X^*\); if \(v\)
can't be on the hull of \(X^*\), then it can't be on the hull
of \(s^*_i\). If \(v\) isn't on the hull of \(s^*_i\), then it is
a reflex vertex; if \(v\) is a reflex vertex, then it can't be on
the convex hull of \(X\), which is a contradiction. As such, \(V
\subseteq V^*\).
</p>
<p>
Because we have \(V \supseteq V^*\) and \(V \subseteq V^*\), we have
\(V=V^*\), and the convex hull of \(X\) is the same as the convex
hull of \(X^*\).
</p>
</div>
<p>The above proof justifies an important optimization wherein only the points
defining the convex hulls of each polygon are stored, as opposed to storing
<em>all</em> points defining each polygon. In practice, removing extraneous points
reduces the number of stored points by ~75%, which saves memory and
computation time. Even though the Reock score is computed using an expected
linear-time algorithm (which, in the worst case, performs quadratically),
reducing the number of points greatly reduces computation time.</p>
<div class="proof">
<p>
<i>Proof (Equality of convex hull of exterior).</i> Let \(S^*\), \(X^*\),
and \(V^*\) be as before. Let \(\partial X^*\) be \(X^*\)'s <i>boundary</i>,
the set of points for which all \(\epsilon\)-neighborhoods intersect
both the interior and exterior faces of \(X^*\). Let \(I^*\) be the
subset of \(S^*\)'s polygons which do not contain a point on the
boundary (i.e. the <i>interior</i> polygons), and let \(E^*\) be the
subset of \(S^*\)'s polygons which contain a point on the boundary
(i.e. the <i>exterior</i> polygons). Note that \(S^* = I^* \sqcup
E^*\).
</p>
<p>
Because each vertex in \(V^*\) is a boundary point, \(E^*\) contains
all polygons with a vertex in \(V^*\). Because each vertex belongs
to a polygon in \(E^*\), we know that \(V^*\) is also the set of
vertices of \(\text{Hull}(\cup E^*)\). Now, because the hulls' vertices
are the same, we have that $$\text{Hull}(X^*) = \text{Hull}(\cup E^*)$$
which, because \(X^* = \cup S^*\), implies that $$\text{Hull}(\cup E^*)
= \text{Hull}\big(\cup(E^* \sqcup I^*)\big) = \text{Hull}(\cup S^*).$$
</p>
</div>
<div class="proof">
<p>
<i>Proof (equality of minimum bounding circles).</i> Given a polygon
\(P\), its minimum bounding disk \(D\) – whose boundary is the minimum
bounding circle \(C\) – necessarily contains \(P\)'s convex hull \(H\), the
minimally convex region containing \(P\), and is defined by at most
three vertices on \(H\). Thus, given two regions whose convex hulls are
the same, the same set of vertices on their hulls define the minimum
bounding disk.
</p>
<p>
Let \(H_X\) be the convex hull of \(X\). Because the convex hulls of
\(X\) and \(H_X\) are the same, the same set of vertices defines
their minimum bounding disks; as such, the minimum bounding circles
of \(X\) and \(H_X\) are the same.
</p>
</div>
<p>The above proofs justify an additional important optimization for computing
Reock scores: because the vertices of our dual graph map bijectively to the
set of geometries to which they're dual, a district isn't a single polygon
but a <em>collection</em> of them. Rather than find the convex hull (and minimum
bounding circle) of the points defining <em>all</em> the geometries which make up the
district, we can more quickly find the hull (and minimum bounding circle) of
the points defining geometries which border other districts or border the
state itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reock(
    geodata: Union[gpd.GeoDataFrame, Graph]
) -&gt; Callable[[GeographicPartition], Dict[Any, float]]:
    r&#34;&#34;&#34;
    Makes a Reock score function specialized to `geodata`.

    The Reock score of a district is its area defined by the area of its
    minimum enclosing circle. Computing the area of this circle is nontrivial,
    and the Reock score is distinct from other popular compactness scores
    (cut edges, Polsby-Popper) in its reliance on full district geometries
    (rather than district areas and perimeters, which can be computed
    efficiently from unit-level statistics).

    We precompute convex hulls of all geometries in `geodata` and
    build an index. The resulting score function uses this index for
    fast geometric computations; the function can only be used with
    dual graphs derived from `geodata`.

    Args:
        geodata (gpd.GeoDataFrame, Graph): Geographical data to precompute
            geometries from.
    Returns:
        A per-district Reock score updater specialized to `geodata`.

    &lt;/br&gt;

    Below, we provide short proofs of correctness for the optimizations utilized
    in this updater. First, we show that the convex hull of a union of tiled
    geometries is the same as the convex hull of the union of the geometries&#39; convex
    hulls. Next, we show that the convex hull of only the exterior tiled geometries
    of a given polygon is the same as the convex hull of all the geometries.
    Lastly, we show that the minimum bounding circle of a given polygon is the
    same as the minimum bounding circle of the polygon&#39;s convex hull.

    &lt;div class=&#34;proof&#34;&gt;
        &lt;p&gt;
            &lt;i&gt;Proof (equality of convex hulls of unions).&lt;/i&gt; Let \(X\) be a simple
            polygon in the plane; let \(S\) be a set of simple polygons \(s_1,
            \dots, s_n\) which tile \(X\) such that \(\cup S = X\), and \(S^*\)
            a set of polygons where \(s^*_i = \text{Hull}(s_i)\). Denote the
            union of polygons in \(S^*\) by \(X^*\), so  that \(\cup S^* = X^*\).
            Let \(V\) be the vertices which define \(\text{Hull}(X)\), and \(V^*\)
            the vertices which define  \(\text{Hull}(X^*)\). We wish to show that
            \(V = V^*\).
        &lt;/p&gt;
        &lt;p&gt;
            (\(\supseteq\)) Each vertex of \(s^*_i\) is a vertex of \(s_i\).
            Consequently, the vertices of \(X^*\) are a subset of \(X\)&#39;s
            vertices, implying that \(\text{Hull}(X^*)\)&#39;s vertices are a subset
            of \(\text{Hull}(X)\)&#39;s. As such, \(V \supseteq V^*\).
        &lt;/p&gt;

        &lt;p&gt;
            (\(\subseteq\)) Suppose, for the sake of contradiction, that \(V\)
            contains a vertex \(v\) that is &lt;i&gt;not&lt;/i&gt; contained in \(V^*\),
            and that \(v\) is a vertex of the polygon \(s_i\). If \(v\) is not
            in \(V^*\), then it can&#39;t be on the hull of \(X^*\); if \(v\)
            can&#39;t be on the hull of \(X^*\), then it can&#39;t be on the hull
            of \(s^*_i\). If \(v\) isn&#39;t on the hull of \(s^*_i\), then it is
            a reflex vertex; if \(v\) is a reflex vertex, then it can&#39;t be on
            the convex hull of \(X\), which is a contradiction. As such, \(V
            \subseteq V^*\).
        &lt;/p&gt;
        &lt;p&gt;
            Because we have \(V \supseteq V^*\) and \(V \subseteq V^*\), we have
            \(V=V^*\), and the convex hull of \(X\) is the same as the convex
            hull of \(X^*\).
        &lt;/p&gt;
    &lt;/div&gt;

    The above proof justifies an important optimization wherein only the points
    defining the convex hulls of each polygon are stored, as opposed to storing
    _all_ points defining each polygon. In practice, removing extraneous points
    reduces the number of stored points by ~75%, which saves memory and
    computation time. Even though the Reock score is computed using an expected
    linear-time algorithm (which, in the worst case, performs quadratically),
    reducing the number of points greatly reduces computation time.

    &lt;div class=&#34;proof&#34;&gt;
        &lt;p&gt;
            &lt;i&gt;Proof (Equality of convex hull of exterior).&lt;/i&gt; Let \(S^*\), \(X^*\),
            and \(V^*\) be as before. Let \(\partial X^*\) be \(X^*\)&#39;s &lt;i&gt;boundary&lt;/i&gt;,
            the set of points for which all \(\epsilon\)-neighborhoods intersect
            both the interior and exterior faces of \(X^*\). Let \(I^*\) be the
            subset of \(S^*\)&#39;s polygons which do not contain a point on the
            boundary (i.e. the &lt;i&gt;interior&lt;/i&gt; polygons), and let \(E^*\) be the
            subset of \(S^*\)&#39;s polygons which contain a point on the boundary
            (i.e. the &lt;i&gt;exterior&lt;/i&gt; polygons). Note that \(S^* = I^* \sqcup
            E^*\).
        &lt;/p&gt;
        &lt;p&gt;
            Because each vertex in \(V^*\) is a boundary point, \(E^*\) contains
            all polygons with a vertex in \(V^*\). Because each vertex belongs
            to a polygon in \(E^*\), we know that \(V^*\) is also the set of
            vertices of \(\text{Hull}(\cup E^*)\). Now, because the hulls&#39; vertices
            are the same, we have that $$\text{Hull}(X^*) = \text{Hull}(\cup E^*)$$
            which, because \(X^* = \cup S^*\), implies that $$\text{Hull}(\cup E^*)
            = \text{Hull}\big(\cup(E^* \sqcup I^*)\big) = \text{Hull}(\cup S^*).$$
        &lt;/p&gt;
    &lt;/div&gt;

    &lt;div class=&#34;proof&#34;&gt;
        &lt;p&gt;
            &lt;i&gt;Proof (equality of minimum bounding circles).&lt;/i&gt; Given a polygon
            \(P\), its minimum bounding disk \(D\) – whose boundary is the minimum
            bounding circle \(C\) – necessarily contains \(P\)&#39;s convex hull \(H\), the
            minimally convex region containing \(P\), and is defined by at most
            three vertices on \(H\). Thus, given two regions whose convex hulls are
            the same, the same set of vertices on their hulls define the minimum
            bounding disk.
        &lt;/p&gt;
        &lt;p&gt;
            Let \(H_X\) be the convex hull of \(X\). Because the convex hulls of
            \(X\) and \(H_X\) are the same, the same set of vertices defines
            their minimum bounding disks; as such, the minimum bounding circles
            of \(X\) and \(H_X\) are the same.
        &lt;/p&gt;
    &lt;/div&gt;

    The above proofs justify an additional important optimization for computing
    Reock scores: because the vertices of our dual graph map bijectively to the
    set of geometries to which they&#39;re dual, a district isn&#39;t a single polygon
    but a _collection_ of them. Rather than find the convex hull (and minimum
    bounding circle) of the points defining _all_ the geometries which make up the
    district, we can more quickly find the hull (and minimum bounding circle) of
    the points defining geometries which border other districts or border the
    state itself.
    &#34;&#34;&#34;
    if isinstance(geodata, gpd.GeoDataFrame):
        geometries = dict(geodata.geometry.apply(lambda p: p.convex_hull))
    elif isinstance(geodata, Graph):
        geometries = {
            node: geom.convex_hull
            for node, geom in geodata.nodes(&#39;geometry&#39;)
        }
    else:
        raise ValueError(
            &#39;Geodata must be a GeoDataFrame or a gerrychain.Graph.&#39;)

    def score_fn(partition: GeographicPartition) -&gt; Dict[Any, float]:
        partition.updaters.update({&#34;boundary_nodes&#34;: boundary_nodes})

        boundary = set.union(*(set(e) for e in partition[&#34;cut_edges&#34;])).union(
            partition[&#34;boundary_nodes&#34;]
        )
        part_scores = {}

        for part, nodes in partition.parts.items():
            geom = unary_union([
                geometries[node] for node in nodes if node in boundary
            ]).convex_hull
            coords = np.array(geom.exterior.coords.xy).T.astype(np.float32)
            _, radius = minEnclosingCircle(coords)
            score = float(partition[&#39;area&#39;][part] / (pi * radius**2))
            assert 0 &lt; score &lt; 1
            part_scores[part] = score
        return part_scores

    return score_fn</code></pre>
</details>
</dd>
<dt id="evaltools.scores.splits"><code class="name flex">
<span>def <span class="ident">splits</span></span>(<span>P, units, names=False) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the number of units split by the districting plan.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>list</code></dt>
<dd>List of data columns; each assigns a vertex to a unit.
Generally, these units are counties, VTDs, precincts, etc.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether we return the identifiers of the things
being split.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping column names to the number of splits or the list
of things split.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splits(P, units, names=False) -&gt; dict:
    &#34;&#34;&#34;
    Determines the number of units split by the districting plan.
    
    Bear in mind that this calculates the number of *unit splits*, not the number
    of *units split*: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county 
    being split).

    Args:
        P (Partition): GerryChain Partition object.
        units (list): List of data columns; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        names (bool, optional): Whether we return the identifiers of the things
            being split.
    
    Returns:
        A dictionary mapping column names to the number of splits or the list
        of things split.
    &#34;&#34;&#34;
    if not names:
        geometrysplits = {
            unit: sum(
                1
                for split in county_splits(&#34;&#34;, unit)(P).values()
                if len(split.contains) &gt; 1
            )
            for unit in units
        }
    else:
        geometrysplits = {
            unit: [
                identifier
                for identifier, split in county_splits(&#34;&#34;, unit)(P).items()
                if len(split.contains) &gt; 1
            ]
            for unit in units
        }

    return geometrysplits</code></pre>
</details>
</dd>
<dt id="evaltools.scores.unassigned_population"><code class="name flex">
<span>def <span class="ident">unassigned_population</span></span>(<span>P, popcolumn)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the number of unassigned people in the districting plan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong></dt>
<dd><code>Partition</code> object.</dd>
<dt><strong><code>popcolumn</code></strong></dt>
<dd>Column for tallying the desired population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Returns a</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unassigned_population(P, popcolumn):
    &#34;&#34;&#34;
    Determines the number of unassigned people in the districting plan.
    
    Args:
        P: `Partition` object.
        popcolumn: Column for tallying the desired population.

    Returns:
        Returns a 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="evaltools.scores.unassigned_units"><code class="name flex">
<span>def <span class="ident">unassigned_units</span></span>(<span>P: gerrychain.partition.partition.Partition, raw: bool = False) ‑> Union[float, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the proportion (or raw number) of units without a district
assignment. An unassigned unit is a unit without a districting assignment an
empty/corrupted assignment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
<dt><strong><code>raw</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, report the raw number of unassigned
units. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>float</code> representing the proportion of units that are unassigned (or
the whole number of unassigned units).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unassigned_units(P: gerrychain.Partition, raw: bool = False) -&gt; Union[float, int]:
    &#34;&#34;&#34;
    Determines the proportion (or raw number) of units without a district
    assignment. An unassigned unit is a unit without a districting assignment an
    empty/corrupted assignment.

    Args:
        P (Partition): GerryChain Partition object.
        raw (bool, optional): If `True`, report the raw number of unassigned
            units. Defaults to `False`.
    
    Returns:
        `float` representing the proportion of units that are unassigned (or
        the whole number of unassigned units).
    &#34;&#34;&#34;
    assignment = P.assignment

    # Retrive the length of the assignment; this corresponds to the number of
    # units which have an assignment key.
    total = len(P.graph.nodes())

    # Next, check for &#34;bad&#34; assignments for units: this includes empty strings
    # and NaNs, for now.
    units_assigned_well = len({
        k: v
        for k, v in assignment.items() if v not in [&#34;nan&#34;, &#34;NaN&#34;, &#34;&#34;]
    })

    return 1-(units_assigned_well/total) if not raw else (total-units_assigned_well)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="evaltools" href="https://github.com/mggg/plan-evaluation-processing">
<style>
header > h1 { display: none; }
img.resize {
max-width: 80%;
max-height: 80%;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
</style>
<img class="resize" src="https://mggg.org/assets/logo.svg" alt="MGGG Logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="evaltools" href="../index.html">evaltools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="evaltools.scores.contiguity" href="contiguity.html">evaltools.scores.contiguity</a></code></li>
<li><code><a title="evaltools.scores.population" href="population.html">evaltools.scores.population</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="evaltools.scores.contiguous" href="#evaltools.scores.contiguous">contiguous</a></code></li>
<li><code><a title="evaltools.scores.deviations" href="#evaltools.scores.deviations">deviations</a></code></li>
<li><code><a title="evaltools.scores.pieces" href="#evaltools.scores.pieces">pieces</a></code></li>
<li><code><a title="evaltools.scores.reock" href="#evaltools.scores.reock">reock</a></code></li>
<li><code><a title="evaltools.scores.splits" href="#evaltools.scores.splits">splits</a></code></li>
<li><code><a title="evaltools.scores.unassigned_population" href="#evaltools.scores.unassigned_population">unassigned_population</a></code></li>
<li><code><a title="evaltools.scores.unassigned_units" href="#evaltools.scores.unassigned_units">unassigned_units</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>