<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools.scoring API documentation</title>
<meta name="description" content="Basic functionality for evaluating districting plans." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>evaltools.scoring</code></h1>
</header>
<section id="section-intro">
<p>Basic functionality for evaluating districting plans.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Basic functionality for evaluating districting plans.
&#34;&#34;&#34;

# from .splits import splits, pieces
from .scores import *
from .population import deviations, unassigned_population
from .contiguity import unassigned_units, contiguous
from .demographics import demographic_updaters
from .reock import reock

__all__ = [
    &#34;splits&#34;,
    &#34;pieces&#34;,
    &#34;competitive_contests&#34;,
    &#34;swing_districts&#34;,
    &#34;party_districts&#34;,
    &#34;opp_party_districts&#34;,
    &#34;party_wins_by_district&#34;,
    &#34;seats&#34;,
    &#34;aggregate_seats&#34;,
    &#34;responsive_proportionality&#34;,
    &#34;stable_proportionality&#34;,
    &#34;efficiency_gap&#34;,
    &#34;simplified_efficiency_gap&#34;,
    &#34;mean_median&#34;,
    &#34;partisan_bias&#34;,
    &#34;partisan_gini&#34;,
    &#34;summarize&#34;,
    &#34;summarize_many&#34;,
    &#34;deviations&#34;,
    &#34;unassigned_population&#34;,
    &#34;unassigned_units&#34;,
    &#34;contiguous&#34;,
    &#34;reock&#34;,
    &#34;demographic_updaters&#34;,
    &#34;demographic_tallies&#34;,
    &#34;demographic_shares&#34;,
    &#34;gingles_districts&#34;,
    &#34;max_deviation&#34;,
    &#34;eguia&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="evaltools.scoring.contiguity" href="contiguity.html">evaltools.scoring.contiguity</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.scoring.demographics" href="demographics.html">evaltools.scoring.demographics</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.scoring.partisan" href="partisan.html">evaltools.scoring.partisan</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.scoring.population" href="population.html">evaltools.scoring.population</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.scoring.score_types" href="score_types.html">evaltools.scoring.score_types</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.scoring.scores" href="scores.html">evaltools.scoring.scores</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.scoring.aggregate_seats"><code class="name flex">
<span>def <span class="ident">aggregate_seats</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many total seats (districts) within a given plan the POV party won across
elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"aggregate_{party}_seats"</code> and associated function that takes a
partition and returns an PlanWideScoreValue for the total number of seats won by the POV
party across elections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate_seats(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many total seats (districts) within a given plan the POV party won across
    elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;aggregate_{party}_seats&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the total number of seats won by the POV
        party across elections.
    &#34;&#34;&#34;
    return Score(f&#34;aggregate_{party}_seats&#34;, partial(_aggregate_seats, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.competitive_contests"><code class="name flex">
<span>def <span class="ident">competitive_contests</span></span>(<span>election_cols: Iterable[str], party: str, points_within: float = 0.03, alias: str = None) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of competitive contests in a plan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>points_within</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The margin from 0.5 that is considered competitive.
Default is 0.03, corresponding to a competitive range of 47%-53%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"competitive_contests_0.03"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of competitive districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def competitive_contests(election_cols: Iterable[str], party: str, points_within: float = 0.03, alias: str = None) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of competitive contests in a plan.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        points_within (float, optional): The margin from 0.5 that is considered competitive.
            Default is 0.03, corresponding to a competitive range of 47%-53%.
    
    Returns:
        A score object with name `&#34;competitive_contests_0.03&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of competitive districts.
    &#34;&#34;&#34;
    if alias is None:
        alias = f&#34;competitive_contests_{points_within}&#34;
    return Score(alias, partial(_competitive_contests, election_cols=election_cols,
                                                  party=party, points_within=points_within))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.contiguous"><code class="name flex">
<span>def <span class="ident">contiguous</span></span>(<span>P: gerrychain.partition.partition.Partition) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the districting plan defined by the partition is
contiguous.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the districting plan defined by the partition is contiguous.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contiguous(P: gerrychain.Partition) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether the districting plan defined by the partition is
    contiguous.

    Args:
        P (Partition): GerryChain Partition object.

    Returns:
        Whether the districting plan defined by the partition is contiguous.
    &#34;&#34;&#34;
    return ctgs(P)</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.demographic_shares"><code class="name flex">
<span>def <span class="ident">demographic_shares</span></span>(<span>population_cols: Mapping[str, Iterable[str]]) ‑> List[<a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A list of scores representing subgroup population shares.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population_cols</code></strong> :&ensp;<code>Mapping[str, Iterable[str]]</code></dt>
<dd>A mapping encoding the total population group
divisor as well as the subgroups to create shares for.
The mapping has the format:
{ <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> : [ <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>, <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span>, &hellip;, <span><span class="MathJax_Preview">P_k</span><script type="math/tex">P_k</script></span>], &hellip;} where <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> is the population and
<span><span class="MathJax_Preview"> P_i \subseteq P </span><script type="math/tex"> P_i \subseteq P </script></span> forall subgroups <span><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of score objects named with the pattern <code>"{column}_share"</code> and with associated
functions that take a partition and return a DistrictWideScoreValue for the demographic
share of each district.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demographic_shares(population_cols: Mapping[str, Iterable[str]]) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing subgroup population shares.

    Args:
        population_cols (Mapping[str, Iterable[str]]): A mapping encoding the total population group
            divisor as well as the subgroups to create shares for.  The mapping has the format:
            { \(P\) : [ \(P_1\), \(P_2\), ..., \(P_k\)], ...} where \(P\) is the population and 
            \( P_i \subseteq P \) forall subgroups \(P_i\).

    Returns:
        A list of score objects named with the pattern `&#34;{column}_share&#34;` and with associated
        functions that take a partition and return a DistrictWideScoreValue for the demographic 
        share of each district.
    &#34;&#34;&#34;
    scores = []

    for totalpop_col, subpop_cols in population_cols.items():
        scores.extend([
            Score(f&#34;{col}_share&#34;, partial(_pop_shares, subpop_col=col, totpop_col=totalpop_col))
            for col in subpop_cols
        ])
    return scores</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.demographic_tallies"><code class="name flex">
<span>def <span class="ident">demographic_tallies</span></span>(<span>population_cols: Iterable[str]) ‑> List[<a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A list of scores representing population tallies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The population column to create tallies for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of score objects named by <code>"{column}"</code> and with associated functions that take a partition
and return a DistrictWideScoreValue for the demographic totals of each district.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demographic_tallies(population_cols: Iterable[str]) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing population tallies.

    Args:
        population_cols (Iterable[str]): The population column to create tallies for.

    Returns:
        A list of score objects named by `&#34;{column}&#34;` and with associated functions that take a partition
        and return a DistrictWideScoreValue for the demographic totals of each district.
    &#34;&#34;&#34;
    return [
            Score(col, partial(_tally_pop, pop_col=col))
            for col in population_cols
        ]</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.demographic_updaters"><code class="name flex">
<span>def <span class="ident">demographic_updaters</span></span>(<span>demographic_keys: Iterable[str], aliases: Iterable[str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demographic_updaters(demographic_keys: Iterable[str], aliases: Iterable[str] = None):
    updaters = {}
    aliases = aliases if aliases else demographic_keys
    for (key, alias) in zip(demographic_keys, aliases):
        updaters[alias] = Tally(key, alias=alias)
    return updaters</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.deviations"><code class="name flex">
<span>def <span class="ident">deviations</span></span>(<span>P, popcolumn) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the districting plan's population deviation percentages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
<dt><strong><code>popcolumn</code></strong> :&ensp;<code>str</code></dt>
<dd>Column for tallying the desired population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary which maps district names to population deviation percentages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deviations(P, popcolumn) -&gt; dict:
    &#34;&#34;&#34;
    Determines the districting plan&#39;s population deviation percentages.
    
    Args:
        P (Partition): GerryChain Partition object.
        popcolumn (str): Column for tallying the desired population.

    Returns:
        A dictionary which maps district names to population deviation percentages.
    &#34;&#34;&#34;
    # Create the partition and the corresponding updater.
    poptally = Tally(popcolumn, alias=popcolumn)
    P.updaters = { popcolumn: poptally }

    # Return a dictionary that maps district names to population deviation
    # percentages.
    return deviation(P, attribute=popcolumn)</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.efficiency_gap"><code class="name flex">
<span>def <span class="ident">efficiency_gap</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the efficiency gap metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"efficiency_gap"</code>
and associated function that takes a partition
and returns a PlanWideScoreValue for efficiency gap metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_gap(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the efficiency gap metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;efficiency_gap&#34;`  and associated function that takes a partition
        and returns a PlanWideScoreValue for efficiency gap metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}efficiency_gap&#34;, partial(_efficiency_gap, election_cols=election_cols, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.eguia"><code class="name flex">
<span>def <span class="ident">eguia</span></span>(<span>election_cols: Iterable[str], party: str, graph: gerrychain.graph.graph.Graph, updaters: Mapping[str, Callable[[gerrychain.partition.partition.Partition], Union[float, int, Mapping[Union[int, str], Union[float, int]], Mapping[str, Union[float, int]]]]], county_col: str, totpop_col: str = 'population', mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the Equia metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>graph</code></strong> :&ensp;<code>gerrychain.Graph</code></dt>
<dd>The underlying dual graph of a partition.
Used to generated a
plan of the counties.</dd>
<dt><strong><code>updaters</code></strong> :&ensp;<code>Mapping[str, Callable[[gerrychain.Partition], ScoreValue]]</code></dt>
<dd>A set of updaters
that contains a tally for the total population by district and the election updaters
whose names are listed in election_cols.</dd>
<dt><strong><code>county_col</code></strong> :&ensp;<code>str</code></dt>
<dd>The column name in the dual graph that encodes the county assignment of
each unit.</dd>
<dt><strong><code>totpop_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the updater that computes total population by
district.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"eguia"</code> and associated function that takes a partition and returns
a PlanWideScoreValue for the eguia metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eguia(election_cols: Iterable[str], party: str, graph: Graph, updaters: Mapping[str, Callable[[Partition], ScoreValue]],
          county_col: str, totpop_col: str = &#34;population&#34;, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the Equia metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        graph (gerrychain.Graph): The underlying dual graph of a partition.  Used to generated a
            plan of the counties.
        updaters (Mapping[str, Callable[[gerrychain.Partition], ScoreValue]]):  A set of updaters
            that contains a tally for the total population by district and the election updaters
            whose names are listed in election_cols.
        county_col (str): The column name in the dual graph that encodes the county assignment of
            each unit.
        totpop_col (str, optional): The name of the updater that computes total population by
            district.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;eguia&#34;` and associated function that takes a partition and returns
        a PlanWideScoreValue for the eguia metric. 
    &#34;&#34;&#34;
    county_part = Partition(graph, county_col, updaters=updaters)
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}eguia&#34;, partial(_eguia, election_cols=election_cols, party=party, 
                                  county_part=county_part, totpop_col=totpop_col, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.gingles_districts"><code class="name flex">
<span>def <span class="ident">gingles_districts</span></span>(<span>population_cols: Mapping[str, Iterable[str]], threshold: float = 0.5) ‑> List[<a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A list of scores representing the number of districts where a sub-population share is above
a given threshold.
When the threshold is 50% these are commonly called Gingles' Districts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population_cols</code></strong> :&ensp;<code>Mapping[str, Iterable[str]]</code></dt>
<dd>A mapping encoding the total population group
divisor as well as the subgroups to create gingles district counters for.
The mapping
has the format: <code>{ \(P\) : [ \(P_1\), \(P_2\), ..., \(P_k\)], ...}</code> where <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> is the
population and <span><span class="MathJax_Preview"> P_i \subseteq P </span><script type="math/tex"> P_i \subseteq P </script></span> forall subgroups <span><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of score objects named with the pattern <code>"{column}_gingles_districts"</code> and with
associated functions that take a partition and return a PlanWideScoreValue for the number of
districts above the population share threshold.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gingles_districts(population_cols: Mapping[str, Iterable[str]], threshold: float = 0.5) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing the number of districts where a sub-population share is above
    a given threshold.  When the threshold is 50% these are commonly called Gingles&#39; Districts.

    Args:
        population_cols (Mapping[str, Iterable[str]]): A mapping encoding the total population group
            divisor as well as the subgroups to create gingles district counters for.  The mapping
            has the format: `{ \(P\) : [ \(P_1\), \(P_2\), ..., \(P_k\)], ...}` where \(P\) is the
            population and \( P_i \subseteq P \) forall subgroups \(P_i\).

    Returns:
        A list of score objects named with the pattern `&#34;{column}_gingles_districts&#34;` and with
        associated functions that take a partition and return a PlanWideScoreValue for the number of
        districts above the population share threshold.
    &#34;&#34;&#34;
    scores = []

    for totalpop_col, subpop_cols in population_cols.items():
        scores.extend([
            Score(f&#34;{col}_gingles_districts&#34;, partial(_gingles_districts, subpop_col=col, 
                                                      totpop_col=totalpop_col, threshold=threshold))
            for col in subpop_cols
        ])
    return scores</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.max_deviation"><code class="name flex">
<span>def <span class="ident">max_deviation</span></span>(<span>totpop_col: str, pct: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum deviation from ideal population size among all the districts.
If <code>pct</code>, return the deviation as a percentage of ideal population size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>totpop_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the updater that computes total population by
district.</dd>
<dt><strong><code>pct</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the maximum deviation as a count or as a percentage of
ideal district size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_deviation(totpop_col: str, pct: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Returns the maximum deviation from ideal population size among all the districts.
    If `pct`, return the deviation as a percentage of ideal population size.

    Args:
        totpop_col (str, optional): The name of the updater that computes total population by
            district.
        pct (bool): Whether to return the maximum deviation as a count or as a percentage of 
                    ideal district size.
    &#34;&#34;&#34;
    return Score(f&#34;{totpop_col}_max_deviation&#34;, partial(_max_deviation, totpop_col=totpop_col, pct=pct))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.mean_median"><code class="name flex">
<span>def <span class="ident">mean_median</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the mean median metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"mean_median"</code> and associated function that takes a partition and
returns a PlanWideScoreValue for the mean median metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_median(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the mean median metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;mean_median&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for the mean median metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}mean_median&#34;, partial(_mean_median, election_cols=election_cols, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.opp_party_districts"><code class="name flex">
<span>def <span class="ident">opp_party_districts</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of districts in a plan that are always won by the opposition party
over a set of elections.
Note that this assumes that all elections are two-party races.
In the case where elections have
more than two parties running this score represents the number of districts that are never won
by the POV party.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"opp_party_districts"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of safe opposition party districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opp_party_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of districts in a plan that are always won by the opposition party
    over a set of elections.
    Note that this assumes that all elections are two-party races.  In the case where elections have
    more than two parties running this score represents the number of districts that are never won
    by the POV party.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;opp_party_districts&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of safe opposition party districts.
    &#34;&#34;&#34;
    return Score(&#34;opp_party_districts&#34;, partial(_opp_party_districts, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.partisan_bias"><code class="name flex">
<span>def <span class="ident">partisan_bias</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the partitisan bias metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"partisan_bias"</code> and associated function that takes a partition and
returns a PlanWideScoreValue for partisan bias metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partisan_bias(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the partitisan bias metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.
    Returns:
        A score object with name `&#34;partisan_bias&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for partisan bias metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}partisan_bias&#34;, partial(_partisan_bias, election_cols=election_cols, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.partisan_gini"><code class="name flex">
<span>def <span class="ident">partisan_gini</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the partisan gini metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"partisan_gini"</code> and associated function that takes a partition and
returns a PlanWideScoreValue for the partisan gini metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partisan_gini(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the partisan gini metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;partisan_gini&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for the partisan gini metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}partisan_gini&#34;, partial(_partisan_gini, election_cols=election_cols, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.party_districts"><code class="name flex">
<span>def <span class="ident">party_districts</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of districts in a plan that are always won by the POV party over
a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"party_districts"</code> and associated function that takes a partition
and returns a PlanWideScoreValue for the number of safe POV party districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def party_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of districts in a plan that are always won by the POV party over
    a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;party_districts&#34;` and associated function that takes a partition
        and returns a PlanWideScoreValue for the number of safe POV party districts.
    &#34;&#34;&#34;
    return Score(&#34;party_districts&#34;, partial(_party_districts, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.party_wins_by_district"><code class="name flex">
<span>def <span class="ident">party_wins_by_district</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many elections the POV party won in each district in a given plan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"party_wins_by_district"</code> and associated function that takes a
partition and returns a DistrictWideScoreValue for the number of elections won by the POV
party in each district.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def party_wins_by_district(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many elections the POV party won in each district in a given plan.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;party_wins_by_district&#34;` and associated function that takes a
        partition and returns a DistrictWideScoreValue for the number of elections won by the POV
        party in each district.
    &#34;&#34;&#34;
    return Score(&#34;party_wins_by_district&#34;, partial(_party_wins_by_district, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.pieces"><code class="name flex">
<span>def <span class="ident">pieces</span></span>(<span>unit: str, names: bool = False, popcol: str = None, how: str = 'pandas', alias: str = None) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of "unit pieces" produced by the plan. For example,
consider a state with 100 counties. Suppose that one county is split twice,
and another once. Then, there are 3 + 2 = 5 "pieces," disregarding the
counties kept whole.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Data column; each assigns a vertex to a unit.
Generally, these units are counties, VTDs, precincts, etc.</dd>
<dt><strong><code>popcol</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The population column on the <code>Partition</code>'s dual
graph. If this is passed, then a unit is only considered "split" if
the <em>populated</em> base units end up in different districts.</dd>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>How do we perform these calculations on the back
end? Acceptable values are <code>"pandas"</code> and <code>"gerrychain"</code>; defaults to
<code>"pandas"</code>.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether we return the identifiers of the things
being split.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with the name <code>"{alias}_pieces"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of pieces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pieces(
        unit:str, names:bool=False, popcol:str=None, how:str=&#34;pandas&#34;,
        alias:str=None
    ) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of &#34;unit pieces&#34; produced by the plan. For example,
    consider a state with 100 counties. Suppose that one county is split twice,
    and another once. Then, there are 3 + 2 = 5 &#34;pieces,&#34; disregarding the
    counties kept whole.
    
    Bear in mind that this calculates the number of _unit splits_, not the number
    of _units split_: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county 
    being split).

    Args:
        unit (str): Data column; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        popcol (str, optional): The population column on the `Partition`&#39;s dual
            graph. If this is passed, then a unit is only considered &#34;split&#34; if
            the _populated_ base units end up in different districts.
        how (str, optional): How do we perform these calculations on the back
            end? Acceptable values are `&#34;pandas&#34;` and `&#34;gerrychain&#34;`; defaults to
            `&#34;pandas&#34;`.
        names (bool, optional): Whether we return the identifiers of the things
            being split.
    
    Returns:
        A score object with the name `&#34;{alias}_pieces&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of pieces.
    &#34;&#34;&#34;
    if alias is None: alias = unit
    
    return Score(
        f&#34;{alias}_pieces&#34;,
        partial(_pieces, unit=unit, how=how, popcol=popcol, names=names)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.reock"><code class="name flex">
<span>def <span class="ident">reock</span></span>(<span>geodata: Union[geopandas.geodataframe.GeoDataFrame, gerrychain.graph.graph.Graph]) ‑> Callable[[gerrychain.partition.geographic.GeographicPartition], Dict[Any, float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a Reock score function specialized to <code>geodata</code>.</p>
<p>The Reock score of a district is its area defined by the area of its
minimum enclosing circle. Computing the area of this circle is nontrivial,
and the Reock score is distinct from other popular compactness scores
(cut edges, Polsby-Popper) in its reliance on full district geometries
(rather than district areas and perimeters, which can be computed
efficiently from unit-level statistics).</p>
<p>We precompute convex hulls of all geometries in <code>geodata</code> and
build an index. The resulting score function uses this index for
fast geometric computations; the function can only be used with
dual graphs derived from <code>geodata</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geodata</code></strong> :&ensp;<code>gpd.GeoDataFrame, Graph</code></dt>
<dd>Geographical data to precompute
geometries from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A per-district Reock score updater specialized to <code>geodata</code>.
</br></p>
<p>Below, we provide short proofs of correctness for the optimizations utilized
in this updater. First, we show that the convex hull of a union of tiled
geometries is the same as the convex hull of the union of the geometries' convex
hulls. Next, we show that the convex hull of only the exterior tiled geometries
of a given polygon is the same as the convex hull of all the geometries.
Lastly, we show that the minimum bounding circle of a given polygon is the
same as the minimum bounding circle of the polygon's convex hull.</p>
<div class="proof">
<p>
<i>Proof (equality of convex hulls of unions).</i> Let \(X\) be a simple
polygon in the plane; let \(S\) be a set of simple polygons \(s_1,
\dots, s_n\) which tile \(X\) such that \(\cup S = X\), and \(S^*\)
a set of polygons where \(s^*_i = \text{Hull}(s_i)\). Denote the
union of polygons in \(S^*\) by \(X^*\), so
that \(\cup S^* = X^*\).
Let \(V\) be the vertices which define \(\text{Hull}(X)\), and \(V^*\)
the vertices which define
\(\text{Hull}(X^*)\). We wish to show that
\(V = V^*\).
</p>
<p>
(\(\supseteq\)) Each vertex of \(s^*_i\) is a vertex of \(s_i\).
Consequently, the vertices of \(X^*\) are a subset of \(X\)'s
vertices, implying that \(\text{Hull}(X^*)\)'s vertices are a subset
of \(\text{Hull}(X)\)'s. As such, \(V \supseteq V^*\).
</p>
<p>
(\(\subseteq\)) Suppose, for the sake of contradiction, that \(V\)
contains a vertex \(v\) that is <i>not</i> contained in \(V^*\),
and that \(v\) is a vertex of the polygon \(s_i\). If \(v\) is not
in \(V^*\), then it can't be on the hull of \(X^*\); if \(v\)
can't be on the hull of \(X^*\), then it can't be on the hull
of \(s^*_i\). If \(v\) isn't on the hull of \(s^*_i\), then it is
a reflex vertex; if \(v\) is a reflex vertex, then it can't be on
the convex hull of \(X\), which is a contradiction. As such, \(V
\subseteq V^*\).
</p>
<p>
Because we have \(V \supseteq V^*\) and \(V \subseteq V^*\), we have
\(V=V^*\), and the convex hull of \(X\) is the same as the convex
hull of \(X^*\).
</p>
</div>
<p>The above proof justifies an important optimization wherein only the points
defining the convex hulls of each polygon are stored, as opposed to storing
<em>all</em> points defining each polygon. In practice, removing extraneous points
reduces the number of stored points by ~75%, which saves memory and
computation time. Even though the Reock score is computed using an expected
linear-time algorithm (which, in the worst case, performs quadratically),
reducing the number of points greatly reduces computation time.</p>
<div class="proof">
<p>
<i>Proof (Equality of convex hull of exterior).</i> Let \(S^*\), \(X^*\),
and \(V^*\) be as before. Let \(\partial X^*\) be \(X^*\)'s <i>boundary</i>,
the set of points for which all \(\epsilon\)-neighborhoods intersect
both the interior and exterior faces of \(X^*\). Let \(I^*\) be the
subset of \(S^*\)'s polygons which do not contain a point on the
boundary (i.e. the <i>interior</i> polygons), and let \(E^*\) be the
subset of \(S^*\)'s polygons which contain a point on the boundary
(i.e. the <i>exterior</i> polygons). Note that \(S^* = I^* \sqcup
E^*\).
</p>
<p>
Because each vertex in \(V^*\) is a boundary point, \(E^*\) contains
all polygons with a vertex in \(V^*\). Because each vertex belongs
to a polygon in \(E^*\), we know that \(V^*\) is also the set of
vertices of \(\text{Hull}(\cup E^*)\). Now, because the hulls' vertices
are the same, we have that $$\text{Hull}(X^*) = \text{Hull}(\cup E^*)$$
which, because \(X^* = \cup S^*\), implies that $$\text{Hull}(\cup E^*)
= \text{Hull}\big(\cup(E^* \sqcup I^*)\big) = \text{Hull}(\cup S^*).$$
</p>
</div>
<div class="proof">
<p>
<i>Proof (equality of minimum bounding circles).</i> Given a polygon
\(P\), its minimum bounding disk \(D\) – whose boundary is the minimum
bounding circle \(C\) – necessarily contains \(P\)'s convex hull \(H\), the
minimally convex region containing \(P\), and is defined by at most
three vertices on \(H\). Thus, given two regions whose convex hulls are
the same, the same set of vertices on their hulls define the minimum
bounding disk.
</p>
<p>
Let \(H_X\) be the convex hull of \(X\). Because the convex hulls of
\(X\) and \(H_X\) are the same, the same set of vertices defines
their minimum bounding disks; as such, the minimum bounding circles
of \(X\) and \(H_X\) are the same.
</p>
</div>
<p>The above proofs justify an additional important optimization for computing
Reock scores: because the vertices of our dual graph map bijectively to the
set of geometries to which they're dual, a district isn't a single polygon
but a <em>collection</em> of them. Rather than find the convex hull (and minimum
bounding circle) of the points defining <em>all</em> the geometries which make up the
district, we can more quickly find the hull (and minimum bounding circle) of
the points defining geometries which border other districts or border the
state itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reock(
        geodata: Union[gpd.GeoDataFrame, Graph]
    ) -&gt; Callable[[GeographicPartition], Dict[Any, float]]:
    r&#34;&#34;&#34;
    Makes a Reock score function specialized to `geodata`.

    The Reock score of a district is its area defined by the area of its
    minimum enclosing circle. Computing the area of this circle is nontrivial,
    and the Reock score is distinct from other popular compactness scores
    (cut edges, Polsby-Popper) in its reliance on full district geometries
    (rather than district areas and perimeters, which can be computed
    efficiently from unit-level statistics).

    We precompute convex hulls of all geometries in `geodata` and
    build an index. The resulting score function uses this index for
    fast geometric computations; the function can only be used with
    dual graphs derived from `geodata`.

    Args:
        geodata (gpd.GeoDataFrame, Graph): Geographical data to precompute
            geometries from.
    Returns:
        A per-district Reock score updater specialized to `geodata`.

    &lt;/br&gt;

    Below, we provide short proofs of correctness for the optimizations utilized
    in this updater. First, we show that the convex hull of a union of tiled
    geometries is the same as the convex hull of the union of the geometries&#39; convex
    hulls. Next, we show that the convex hull of only the exterior tiled geometries
    of a given polygon is the same as the convex hull of all the geometries.
    Lastly, we show that the minimum bounding circle of a given polygon is the
    same as the minimum bounding circle of the polygon&#39;s convex hull.

    &lt;div class=&#34;proof&#34;&gt;
        &lt;p&gt;
            &lt;i&gt;Proof (equality of convex hulls of unions).&lt;/i&gt; Let \(X\) be a simple
            polygon in the plane; let \(S\) be a set of simple polygons \(s_1,
            \dots, s_n\) which tile \(X\) such that \(\cup S = X\), and \(S^*\)
            a set of polygons where \(s^*_i = \text{Hull}(s_i)\). Denote the
            union of polygons in \(S^*\) by \(X^*\), so  that \(\cup S^* = X^*\).
            Let \(V\) be the vertices which define \(\text{Hull}(X)\), and \(V^*\)
            the vertices which define  \(\text{Hull}(X^*)\). We wish to show that
            \(V = V^*\).
        &lt;/p&gt;
        &lt;p&gt;
            (\(\supseteq\)) Each vertex of \(s^*_i\) is a vertex of \(s_i\).
            Consequently, the vertices of \(X^*\) are a subset of \(X\)&#39;s
            vertices, implying that \(\text{Hull}(X^*)\)&#39;s vertices are a subset
            of \(\text{Hull}(X)\)&#39;s. As such, \(V \supseteq V^*\).
        &lt;/p&gt;

        &lt;p&gt;
            (\(\subseteq\)) Suppose, for the sake of contradiction, that \(V\)
            contains a vertex \(v\) that is &lt;i&gt;not&lt;/i&gt; contained in \(V^*\),
            and that \(v\) is a vertex of the polygon \(s_i\). If \(v\) is not
            in \(V^*\), then it can&#39;t be on the hull of \(X^*\); if \(v\)
            can&#39;t be on the hull of \(X^*\), then it can&#39;t be on the hull
            of \(s^*_i\). If \(v\) isn&#39;t on the hull of \(s^*_i\), then it is
            a reflex vertex; if \(v\) is a reflex vertex, then it can&#39;t be on
            the convex hull of \(X\), which is a contradiction. As such, \(V
            \subseteq V^*\).
        &lt;/p&gt;
        &lt;p&gt;
            Because we have \(V \supseteq V^*\) and \(V \subseteq V^*\), we have
            \(V=V^*\), and the convex hull of \(X\) is the same as the convex
            hull of \(X^*\).
        &lt;/p&gt;
    &lt;/div&gt;

    The above proof justifies an important optimization wherein only the points
    defining the convex hulls of each polygon are stored, as opposed to storing
    _all_ points defining each polygon. In practice, removing extraneous points
    reduces the number of stored points by ~75%, which saves memory and
    computation time. Even though the Reock score is computed using an expected
    linear-time algorithm (which, in the worst case, performs quadratically),
    reducing the number of points greatly reduces computation time.

    &lt;div class=&#34;proof&#34;&gt;
        &lt;p&gt;
            &lt;i&gt;Proof (Equality of convex hull of exterior).&lt;/i&gt; Let \(S^*\), \(X^*\),
            and \(V^*\) be as before. Let \(\partial X^*\) be \(X^*\)&#39;s &lt;i&gt;boundary&lt;/i&gt;,
            the set of points for which all \(\epsilon\)-neighborhoods intersect
            both the interior and exterior faces of \(X^*\). Let \(I^*\) be the
            subset of \(S^*\)&#39;s polygons which do not contain a point on the
            boundary (i.e. the &lt;i&gt;interior&lt;/i&gt; polygons), and let \(E^*\) be the
            subset of \(S^*\)&#39;s polygons which contain a point on the boundary
            (i.e. the &lt;i&gt;exterior&lt;/i&gt; polygons). Note that \(S^* = I^* \sqcup
            E^*\).
        &lt;/p&gt;
        &lt;p&gt;
            Because each vertex in \(V^*\) is a boundary point, \(E^*\) contains
            all polygons with a vertex in \(V^*\). Because each vertex belongs
            to a polygon in \(E^*\), we know that \(V^*\) is also the set of
            vertices of \(\text{Hull}(\cup E^*)\). Now, because the hulls&#39; vertices
            are the same, we have that $$\text{Hull}(X^*) = \text{Hull}(\cup E^*)$$
            which, because \(X^* = \cup S^*\), implies that $$\text{Hull}(\cup E^*)
            = \text{Hull}\big(\cup(E^* \sqcup I^*)\big) = \text{Hull}(\cup S^*).$$
        &lt;/p&gt;
    &lt;/div&gt;

    &lt;div class=&#34;proof&#34;&gt;
        &lt;p&gt;
            &lt;i&gt;Proof (equality of minimum bounding circles).&lt;/i&gt; Given a polygon
            \(P\), its minimum bounding disk \(D\) – whose boundary is the minimum
            bounding circle \(C\) – necessarily contains \(P\)&#39;s convex hull \(H\), the
            minimally convex region containing \(P\), and is defined by at most
            three vertices on \(H\). Thus, given two regions whose convex hulls are
            the same, the same set of vertices on their hulls define the minimum
            bounding disk.
        &lt;/p&gt;
        &lt;p&gt;
            Let \(H_X\) be the convex hull of \(X\). Because the convex hulls of
            \(X\) and \(H_X\) are the same, the same set of vertices defines
            their minimum bounding disks; as such, the minimum bounding circles
            of \(X\) and \(H_X\) are the same.
        &lt;/p&gt;
    &lt;/div&gt;

    The above proofs justify an additional important optimization for computing
    Reock scores: because the vertices of our dual graph map bijectively to the
    set of geometries to which they&#39;re dual, a district isn&#39;t a single polygon
    but a _collection_ of them. Rather than find the convex hull (and minimum
    bounding circle) of the points defining _all_ the geometries which make up the
    district, we can more quickly find the hull (and minimum bounding circle) of
    the points defining geometries which border other districts or border the
    state itself.
    &#34;&#34;&#34;
    if isinstance(geodata, gpd.GeoDataFrame):
        geometries = dict(geodata.geometry.apply(lambda p: p.convex_hull))
    elif isinstance(geodata, Graph):
        geometries = {
            node: geom.convex_hull
            for node, geom in geodata.nodes(&#39;geometry&#39;)
        }
    else:
        raise ValueError(
            &#39;Geodata must be a GeoDataFrame or a gerrychain.Graph.&#39;)

    def score_fn(partition: GeographicPartition) -&gt; Dict[Any, float]:
        partition.updaters.update({&#34;boundary_nodes&#34;: boundary_nodes})

        boundary = set.union(*(set(e) for e in partition[&#34;cut_edges&#34;])).union(
            partition[&#34;boundary_nodes&#34;]
        )
        part_scores = {}

        for part, nodes in partition.parts.items():
            geom = unary_union([
                geometries[node] for node in nodes if node in boundary
            ]).convex_hull
            coords = np.array(geom.exterior.coords.xy).T.astype(np.float32)
            _, radius = minEnclosingCircle(coords)
            score = float(partition[&#39;area&#39;][part] / (pi * radius**2))
            assert 0 &lt; score &lt; 1
            part_scores[part] = score
        return part_scores

    return score_fn</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.responsive_proportionality"><code class="name flex">
<span>def <span class="ident">responsive_proportionality</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many the responsive proportionality across a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"responsive_proportionality"</code> and associated function that takes a
partition and returns an PlanWideScoreValue for the responsive proportionality across the
elections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def responsive_proportionality(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many the responsive proportionality across a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;responsive_proportionality&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the responsive proportionality across the
        elections.
    &#34;&#34;&#34;
    return Score(f&#34;responsive_proportionality&#34;, partial(_responsive_proportionality, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.seats"><code class="name flex">
<span>def <span class="ident">seats</span></span>(<span>election_cols: Iterable[str], party: str, mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many seats (districts) within a given plan the POV party won in each
election </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"{party}_seats"</code> and associated function that takes a partition and
returns an ElectionWideScoreValue for the number of seats won by the POV party for each
election.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seats(election_cols: Iterable[str], party: str, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many seats (districts) within a given plan the POV party won in each
    election 

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;{party}_seats&#34;` and associated function that takes a partition and
        returns an ElectionWideScoreValue for the number of seats won by the POV party for each
        election.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}{party}_seats&#34;, partial(_seats, election_cols=election_cols, party=party, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.simplified_efficiency_gap"><code class="name flex">
<span>def <span class="ident">simplified_efficiency_gap</span></span>(<span>election_cols: Iterable[str], party: str, mean: bool = False) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the simplified efficiency gap metric of a plan with respect to a set of elections.
The original formulation of efficiency gap quantifies the difference in "wasted" votes for the two
parties across the state, as a share of votes cast. This is sensitive to turnout effects. The
simplified score is equal to standard efficiency gap when the districts have equal turnout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"efficiency_gap"</code>
and associated function that takes a partition
and returns a PlanWideScoreValue for efficiency gap metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplified_efficiency_gap(election_cols: Iterable[str], party: str, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the simplified efficiency gap metric of a plan with respect to a set of elections.
    The original formulation of efficiency gap quantifies the difference in &#34;wasted&#34; votes for the two
    parties across the state, as a share of votes cast. This is sensitive to turnout effects. The 
    simplified score is equal to standard efficiency gap when the districts have equal turnout.
    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.
    Returns:
        A score object with name `&#34;efficiency_gap&#34;`  and associated function that takes a partition
        and returns a PlanWideScoreValue for efficiency gap metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(f&#34;{prefix}simplified_efficiency_gap&#34;, partial(_simplified_efficiency_gap, election_cols=election_cols, party=party, mean=mean))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.splits"><code class="name flex">
<span>def <span class="ident">splits</span></span>(<span>unit: str, names: bool = False, popcol: str = None, how: str = 'pandas', alias: str = None) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of units split by the districting plan.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Data column; each assigns a vertex to a unit.
Generally, these units are counties, VTDs, precincts, etc.</dd>
<dt><strong><code>popcol</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The population column on the <code>Partition</code>'s dual
graph. If this is passed, then a unit is only considered "split" if
the <em>populated</em> base units end up in different districts.</dd>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>How do we perform these calculations on the back
end? Acceptable values are <code>"pandas"</code> and <code>"gerrychain"</code>; defaults to
<code>"pandas"</code>.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether we return the identifiers of the things
being split.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with the name <code>"{alias}_splits"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of splits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splits(
        unit:str, names:bool=False, popcol:str=None, how:str=&#34;pandas&#34;,
        alias:str=None
    ) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of units split by the districting plan.
    
    Bear in mind that this calculates the number of *unit splits*, not the number
    of *units split*: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county 
    being split).

    Args:
        unit (str): Data column; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        popcol (str, optional): The population column on the `Partition`&#39;s dual
            graph. If this is passed, then a unit is only considered &#34;split&#34; if
            the _populated_ base units end up in different districts.
        how (str, optional): How do we perform these calculations on the back
            end? Acceptable values are `&#34;pandas&#34;` and `&#34;gerrychain&#34;`; defaults to
            `&#34;pandas&#34;`.
        names (bool, optional): Whether we return the identifiers of the things
            being split.
    
    Returns:
        A score object with the name `&#34;{alias}_splits&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of splits.
    &#34;&#34;&#34;
    if alias is None: alias = unit
    
    return Score(
        f&#34;{alias}_splits&#34;,
        partial(_splits, unit=unit, how=how, popcol=popcol, names=names)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.stable_proportionality"><code class="name flex">
<span>def <span class="ident">stable_proportionality</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many the stable proportionality across a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"stable_proportionality"</code> and associated function that takes a
partition and returns an PlanWideScoreValue for the stable proportionality across the
elections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stable_proportionality(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many the stable proportionality across a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;stable_proportionality&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the stable proportionality across the
        elections.
    &#34;&#34;&#34;
    return Score(f&#34;stable_proportionality&#34;, partial(_stable_proportionality, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>part: gerrychain.partition.partition.Partition, scores: Iterable[<a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a>]) ‑> Dict[str, Union[float, int, Mapping[Union[int, str], Union[float, int]], Mapping[str, Union[float, int]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Summarize the given partition by the passed scores.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>part</code></strong> :&ensp;<code>Partition</code></dt>
<dd>The plan to summarize.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>Iterable[Score]</code></dt>
<dd>Which scores to include in the summary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that maps score names to the corresponding ScoreValues of the score functions
applied to the plan.</p>
<p>ie.
<code>{"cut_edges": 4050, "num_party_seats": 3, ... }</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(part: Partition, scores: Iterable[Score]) -&gt; Dict[str, ScoreValue]:
    &#34;&#34;&#34;
    Summarize the given partition by the passed scores.

    Args:
        part (Partition): The plan to summarize.
        scores (Iterable[Score]): Which scores to include in the summary.

    Returns:
        A dictionary that maps score names to the corresponding ScoreValues of the score functions
        applied to the plan.

        ie.
        `{&#34;cut_edges&#34;: 4050, &#34;num_party_seats&#34;: 3, ... }`
    &#34;&#34;&#34;
    summary = {}
    for score in scores:
        summary[score.name] = score.apply(part)
    return summary</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.summarize_many"><code class="name flex">
<span>def <span class="ident">summarize_many</span></span>(<span>parts: Iterable[gerrychain.partition.partition.Partition], scores: Iterable[<a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a>], plan_names: List[str] = [], output_file: str = None, compress: bool = False, verbose: bool = False) ‑> Optional[List[Dict[str, Union[float, int, Mapping[Union[int, str], Union[float, int]], Mapping[str, Union[float, int]]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Summarize the given partitions by the passed scores.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parts</code></strong> :&ensp;<code>Iterable[Partition]</code></dt>
<dd>The plans to summarize.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>Iterable[Score]</code></dt>
<dd>Which scores to include in the summaries.</dd>
<dt><strong><code>plan_names</code></strong> :&ensp;<code>Iterable[str]</code>, optional</dt>
<dd>Plan identifiers, corresponding to plan by index.
If
no plan name exist for a given plan's index the plan's index is used as the identifier.
Default is <code>[]</code>, plans identified by index.</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of file to save the results jsonl encoding of the scores.
If None, returns a list of the dictionary summary of each plan.
Defaults to None.</dd>
<dt><strong><code>compress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to compress the output file with gzip.
Default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list dictionaries that maps score names to the corresponding ScoreValues of the score
functions applied to each plan, if NO output file is passed.</p>
<p>If an output file IS specified, the plan summaries are written to file and the function
is void.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize_many(parts: Iterable[Partition], scores: Iterable[Score], plan_names: List[str] = [],
                   output_file: str = None, compress: bool = False, verbose : bool = False) -&gt; Union[List[Dict[str, ScoreValue]], None]:
    &#34;&#34;&#34;
    Summarize the given partitions by the passed scores.

    Args:
        parts (Iterable[Partition]): The plans to summarize.
        scores (Iterable[Score]): Which scores to include in the summaries.
        plan_names (Iterable[str], optional): Plan identifiers, corresponding to plan by index.  If
            no plan name exist for a given plan&#39;s index the plan&#39;s index is used as the identifier.
            Default is `[]`, plans identified by index.
        output_file (str, optional): Name of file to save the results jsonl encoding of the scores.
            If None, returns a list of the dictionary summary of each plan.  Defaults to None.
        compress (bool, optional): Whether to compress the output file with gzip.  Default is False.

    Returns:
        A list dictionaries that maps score names to the corresponding ScoreValues of the score
        functions applied to each plan, if NO output file is passed.

        If an output file IS specified, the plan summaries are written to file and the function
        is void.
    &#34;&#34;&#34;
    if output_file is None:
        if verbose:
            result = []
            for part in tqdm(parts):
                result.append(summarize(part, scores=scores))
            return result
        return [summarize(part, scores=scores) for part in parts]
    else:
        with gzip.open(f&#34;{output_file}.gz&#34;, &#34;wt&#34;) if compress else open(output_file, &#34;w&#34;) as fout:
            iterator = tqdm(enumerate(parts)) if verbose else enumerate(parts)
            for i, part in iterator:
                plan_details = summarize(part, scores=scores)
                try:
                    plan_details[&#34;id&#34;] = plan_names[i]
                except:
                    plan_details[&#34;id&#34;] = i
                fout.write(json.dumps(plan_details) + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.swing_districts"><code class="name flex">
<span>def <span class="ident">swing_districts</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.score_types.Score" href="score_types.html#evaltools.scoring.score_types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of swing districts in a plan.
A swing districts is one that is
not solely won by a single party over a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"swing_districts"</code> and associated function that takes a partition
and returns a PlanWideScoreValue for the number of swing districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swing_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of swing districts in a plan.  A swing districts is one that is
    not solely won by a single party over a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;swing_districts&#34;` and associated function that takes a partition
        and returns a PlanWideScoreValue for the number of swing districts.
    &#34;&#34;&#34;
    return Score(&#34;swing_districts&#34;, partial(_swing_districts, election_cols=election_cols, party=party))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.unassigned_population"><code class="name flex">
<span>def <span class="ident">unassigned_population</span></span>(<span>P, popcolumn)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the number of unassigned people in the districting plan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong></dt>
<dd><code>Partition</code> object.</dd>
<dt><strong><code>popcolumn</code></strong></dt>
<dd>Column for tallying the desired population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Returns a</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unassigned_population(P, popcolumn):
    &#34;&#34;&#34;
    Determines the number of unassigned people in the districting plan.
    
    Args:
        P: `Partition` object.
        popcolumn: Column for tallying the desired population.

    Returns:
        Returns a 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.unassigned_units"><code class="name flex">
<span>def <span class="ident">unassigned_units</span></span>(<span>P: gerrychain.partition.partition.Partition, raw: bool = False) ‑> Union[float, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the proportion (or raw number) of units without a district
assignment. An unassigned unit is a unit without a districting assignment an
empty/corrupted assignment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>Partition</code></dt>
<dd>GerryChain Partition object.</dd>
<dt><strong><code>raw</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, report the raw number of unassigned
units. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>float</code> representing the proportion of units that are unassigned (or
the whole number of unassigned units).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unassigned_units(P: gerrychain.Partition, raw: bool = False) -&gt; Union[float, int]:
    &#34;&#34;&#34;
    Determines the proportion (or raw number) of units without a district
    assignment. An unassigned unit is a unit without a districting assignment an
    empty/corrupted assignment.

    Args:
        P (Partition): GerryChain Partition object.
        raw (bool, optional): If `True`, report the raw number of unassigned
            units. Defaults to `False`.
    
    Returns:
        `float` representing the proportion of units that are unassigned (or
        the whole number of unassigned units).
    &#34;&#34;&#34;
    assignment = P.assignment

    # Retrive the length of the assignment; this corresponds to the number of
    # units which have an assignment key.
    total = len(P.graph.nodes())

    # Next, check for &#34;bad&#34; assignments for units: this includes empty strings
    # and NaNs, for now.
    units_assigned_well = len({
        k: v
        for k, v in assignment.items() if v not in [&#34;nan&#34;, &#34;NaN&#34;, &#34;&#34;]
    })

    return 1-(units_assigned_well/total) if not raw else (total-units_assigned_well)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="evaltools" href="https://github.com/mggg/plan-evaluation-processing">
<style>
header > h1 { display: none; }
img.resize {
max-width: 80%;
max-height: 80%;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
</style>
<img class="resize" src="https://mggg.org/assets/logo.svg" alt="MGGG Logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="evaltools" href="../index.html">evaltools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="evaltools.scoring.contiguity" href="contiguity.html">evaltools.scoring.contiguity</a></code></li>
<li><code><a title="evaltools.scoring.demographics" href="demographics.html">evaltools.scoring.demographics</a></code></li>
<li><code><a title="evaltools.scoring.partisan" href="partisan.html">evaltools.scoring.partisan</a></code></li>
<li><code><a title="evaltools.scoring.population" href="population.html">evaltools.scoring.population</a></code></li>
<li><code><a title="evaltools.scoring.score_types" href="score_types.html">evaltools.scoring.score_types</a></code></li>
<li><code><a title="evaltools.scoring.scores" href="scores.html">evaltools.scoring.scores</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="evaltools.scoring.aggregate_seats" href="#evaltools.scoring.aggregate_seats">aggregate_seats</a></code></li>
<li><code><a title="evaltools.scoring.competitive_contests" href="#evaltools.scoring.competitive_contests">competitive_contests</a></code></li>
<li><code><a title="evaltools.scoring.contiguous" href="#evaltools.scoring.contiguous">contiguous</a></code></li>
<li><code><a title="evaltools.scoring.demographic_shares" href="#evaltools.scoring.demographic_shares">demographic_shares</a></code></li>
<li><code><a title="evaltools.scoring.demographic_tallies" href="#evaltools.scoring.demographic_tallies">demographic_tallies</a></code></li>
<li><code><a title="evaltools.scoring.demographic_updaters" href="#evaltools.scoring.demographic_updaters">demographic_updaters</a></code></li>
<li><code><a title="evaltools.scoring.deviations" href="#evaltools.scoring.deviations">deviations</a></code></li>
<li><code><a title="evaltools.scoring.efficiency_gap" href="#evaltools.scoring.efficiency_gap">efficiency_gap</a></code></li>
<li><code><a title="evaltools.scoring.eguia" href="#evaltools.scoring.eguia">eguia</a></code></li>
<li><code><a title="evaltools.scoring.gingles_districts" href="#evaltools.scoring.gingles_districts">gingles_districts</a></code></li>
<li><code><a title="evaltools.scoring.max_deviation" href="#evaltools.scoring.max_deviation">max_deviation</a></code></li>
<li><code><a title="evaltools.scoring.mean_median" href="#evaltools.scoring.mean_median">mean_median</a></code></li>
<li><code><a title="evaltools.scoring.opp_party_districts" href="#evaltools.scoring.opp_party_districts">opp_party_districts</a></code></li>
<li><code><a title="evaltools.scoring.partisan_bias" href="#evaltools.scoring.partisan_bias">partisan_bias</a></code></li>
<li><code><a title="evaltools.scoring.partisan_gini" href="#evaltools.scoring.partisan_gini">partisan_gini</a></code></li>
<li><code><a title="evaltools.scoring.party_districts" href="#evaltools.scoring.party_districts">party_districts</a></code></li>
<li><code><a title="evaltools.scoring.party_wins_by_district" href="#evaltools.scoring.party_wins_by_district">party_wins_by_district</a></code></li>
<li><code><a title="evaltools.scoring.pieces" href="#evaltools.scoring.pieces">pieces</a></code></li>
<li><code><a title="evaltools.scoring.reock" href="#evaltools.scoring.reock">reock</a></code></li>
<li><code><a title="evaltools.scoring.responsive_proportionality" href="#evaltools.scoring.responsive_proportionality">responsive_proportionality</a></code></li>
<li><code><a title="evaltools.scoring.seats" href="#evaltools.scoring.seats">seats</a></code></li>
<li><code><a title="evaltools.scoring.simplified_efficiency_gap" href="#evaltools.scoring.simplified_efficiency_gap">simplified_efficiency_gap</a></code></li>
<li><code><a title="evaltools.scoring.splits" href="#evaltools.scoring.splits">splits</a></code></li>
<li><code><a title="evaltools.scoring.stable_proportionality" href="#evaltools.scoring.stable_proportionality">stable_proportionality</a></code></li>
<li><code><a title="evaltools.scoring.summarize" href="#evaltools.scoring.summarize">summarize</a></code></li>
<li><code><a title="evaltools.scoring.summarize_many" href="#evaltools.scoring.summarize_many">summarize_many</a></code></li>
<li><code><a title="evaltools.scoring.swing_districts" href="#evaltools.scoring.swing_districts">swing_districts</a></code></li>
<li><code><a title="evaltools.scoring.unassigned_population" href="#evaltools.scoring.unassigned_population">unassigned_population</a></code></li>
<li><code><a title="evaltools.scoring.unassigned_units" href="#evaltools.scoring.unassigned_units">unassigned_units</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>