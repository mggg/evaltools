<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools.scoring.scores API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>evaltools.scoring.scores</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .splits import _splits, _pieces
from .demographics import (
    _pop_shares,
    _tally_pop,
    _gingles_districts,
    _max_deviation,
)
from .partisan import (
    _competitive_contests,
    _swing_districts,
    _party_districts,
    _opp_party_districts,
    _party_wins_by_district,
    _seats,
    _aggregate_seats,
    _efficiency_gap,
    _simplified_efficiency_gap,
    _mean_median,
    _partisan_bias,
    _partisan_gini,
    _eguia,
    _stable_proportionality,
    _responsive_proportionality,
)
from functools import partial
from gerrychain import Partition, Graph
from typing import Iterable, List, Mapping, Dict, Union
from tqdm import tqdm
import gzip
import json
from .types import Score, ScoreValue, Callable


def summarize(part: Partition, scores: Iterable[Score]) -&gt; Dict[str, ScoreValue]:
    &#34;&#34;&#34;
    Summarize the given partition by the passed scores.

    Args:
        part (Partition): The plan to summarize.
        scores (Iterable[Score]): Which scores to include in the summary.

    Returns:
        A dictionary that maps score names to the corresponding ScoreValues of the score functions
        applied to the plan.

        ie.
        `{&#34;cut_edges&#34;: 4050, &#34;num_party_seats&#34;: 3, ... }`
    &#34;&#34;&#34;
    summary = {}
    for score in scores:
        summary[score.name] = score.apply(part)
    return summary


def summarize_many(
    parts: Iterable[Partition], scores: Iterable[Score], plan_names: List[str] = [],
    output_file: str = None, compress: bool = False, verbose: bool = False
) -&gt; Union[List[Dict[str, ScoreValue]], None]:
    &#34;&#34;&#34;
    Summarize the given partitions by the passed scores.

    Args:
        parts (Iterable[Partition]): The plans to summarize.
        scores (Iterable[Score]): Which scores to include in the summaries.
        plan_names (Iterable[str], optional): Plan identifiers, corresponding to
            plan by index. If no plan name exists for a given plan&#39;s index, the
            plan&#39;s index is used as the identifier. Default is `[]`, plans
            identified by index.
        output_file (str, optional): Name of file to save the results jsonl
            encoding of the scores. If None, returns a list of the dictionary
            summary of each plan. Defaults to None.
        compress (bool, optional): Whether to compress the output file with gzip.
            Default is False.

    Returns:
        A list dictionaries that maps score names to the corresponding ScoreValues
        of the score functions applied to each plan, if NO output file is passed.
        If an output file IS specified, the plan summaries are written to file
        and the function is void.
    &#34;&#34;&#34;
    if output_file is None:
        if verbose:
            result = []
            for part in tqdm(parts):
                result.append(summarize(part, scores=scores))
            return result
        return [summarize(part, scores=scores) for part in parts]
    else:
        with gzip.open(f&#34;{output_file}.gz&#34;, &#34;wt&#34;) if compress else open(output_file, &#34;w&#34;) as fout:
            iterator = tqdm(enumerate(parts)) if verbose else enumerate(parts)
            for i, part in iterator:
                plan_details = summarize(part, scores=scores)
                try:
                    plan_details[&#34;id&#34;] = plan_names[i]
                except BaseException:
                    plan_details[&#34;id&#34;] = i
                fout.write(json.dumps(plan_details) + &#34;\n&#34;)


def splits(
    unit: str, names: bool = False, popcol: str = None, how: str = &#34;pandas&#34;,
    alias: str = None
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of units split by the districting plan.

    Bear in mind that this calculates the number of *unit splits*, not the number
    of *units split*: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county
    being split).

    Args:
        unit (str): Data column; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        popcol (str, optional): The population column on the `Partition`&#39;s dual
            graph. If this is passed, then a unit is only considered &#34;split&#34; if
            the _populated_ base units end up in different districts.
        how (str, optional): How do we perform these calculations on the back
            end? Acceptable values are `&#34;pandas&#34;` and `&#34;gerrychain&#34;`; defaults to
            `&#34;pandas&#34;`.
        names (bool, optional): Whether we return the identifiers of the things
            being split.

    Returns:
        A score object with the name `&#34;{alias}_splits&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of splits.
    &#34;&#34;&#34;
    if alias is None:
        alias = unit

    return Score(
        f&#34;{alias}_splits&#34;,
        partial(_splits, unit=unit, how=how, popcol=popcol, names=names)
    )


def pieces(
    unit: str, names: bool = False, popcol: str = None, how: str = &#34;pandas&#34;,
    alias: str = None
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of &#34;unit pieces&#34; produced by the plan. For example,
    consider a state with 100 counties. Suppose that one county is split twice,
    and another once. Then, there are 3 + 2 = 5 &#34;pieces,&#34; disregarding the
    counties kept whole.

    Bear in mind that this calculates the number of _unit splits_, not the number
    of _units split_: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county
    being split).

    Args:
        unit (str): Data column; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        popcol (str, optional): The population column on the `Partition`&#39;s dual
            graph. If this is passed, then a unit is only considered &#34;split&#34; if
            the _populated_ base units end up in different districts.
        how (str, optional): How do we perform these calculations on the back
            end? Acceptable values are `&#34;pandas&#34;` and `&#34;gerrychain&#34;`; defaults to
            `&#34;pandas&#34;`.
        names (bool, optional): Whether we return the identifiers of the things
            being split.

    Returns:
        A score object with the name `&#34;{alias}_pieces&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of pieces.
    &#34;&#34;&#34;
    if alias is None:
        alias = unit

    return Score(
        f&#34;{alias}_pieces&#34;,
        partial(_pieces, unit=unit, how=how, popcol=popcol, names=names)
    )


def competitive_contests(
    election_cols: Iterable[str], party: str, points_within: float = 0.03,
    alias: str = None
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of competitive contests in a plan.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        points_within (float, optional): The margin from 0.5 that is considered competitive.
            Default is 0.03, corresponding to a competitive range of 47%-53%.

    Returns:
        A score object with name `&#34;competitive_contests_0.03&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of competitive districts.
    &#34;&#34;&#34;
    if alias is None:
        alias = f&#34;competitive_contests_{points_within}&#34;
    return Score(
        alias,
        partial(
            _competitive_contests, election_cols=election_cols, party=party,
            points_within=points_within
        )
    )


def swing_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of swing districts in a plan.  A swing districts is one that is
    not solely won by a single party over a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;swing_districts&#34;` and associated function that takes a partition
        and returns a PlanWideScoreValue for the number of swing districts.
    &#34;&#34;&#34;
    return Score(
        &#34;swing_districts&#34;,
        partial(_swing_districts, election_cols=election_cols, party=party)
    )


def party_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of districts in a plan that are always won by the POV party over
    a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;party_districts&#34;` and associated function that takes a partition
        and returns a PlanWideScoreValue for the number of safe POV party districts.
    &#34;&#34;&#34;
    return Score(
        &#34;party_districts&#34;,
        partial(_party_districts, election_cols=election_cols, party=party)
    )


def opp_party_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of districts in a plan that are always won by the opposition party
    over a set of elections.
    Note that this assumes that all elections are two-party races.  In the case where elections have
    more than two parties running this score represents the number of districts that are never won
    by the POV party.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;opp_party_districts&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of safe opposition party districts.
    &#34;&#34;&#34;
    return Score(
        &#34;opp_party_districts&#34;,
        partial(_opp_party_districts, election_cols=election_cols, party=party)
    )


def party_wins_by_district(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many elections the POV party won in each district in a given plan.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;party_wins_by_district&#34;` and associated function that takes a
        partition and returns a DistrictWideScoreValue for the number of elections won by the POV
        party in each district.
    &#34;&#34;&#34;
    return Score(
        &#34;party_wins_by_district&#34;,
        partial(_party_wins_by_district, election_cols=election_cols, party=party)
    )


def seats(election_cols: Iterable[str], party: str, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many seats (districts) within a given plan the POV party won in each
    election

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;{party}_seats&#34;` and associated function that takes a partition and
        returns an ElectionWideScoreValue for the number of seats won by the POV party for each
        election.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}{party}_seats&#34;,
        partial(_seats, election_cols=election_cols, party=party, mean=mean)
    )


def aggregate_seats(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many total seats (districts) within a given plan the POV party won across
    elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;aggregate_{party}_seats&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the total number of seats won by the POV
        party across elections.
    &#34;&#34;&#34;
    return Score(
        f&#34;aggregate_{party}_seats&#34;,
        partial(_aggregate_seats, election_cols=election_cols, party=party)
    )


def responsive_proportionality(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many the responsive proportionality across a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;responsive_proportionality&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the responsive proportionality across the
        elections.
    &#34;&#34;&#34;
    return Score(
        &#34;responsive_proportionality&#34;,
        partial(
            _responsive_proportionality, election_cols=election_cols, party=party
        )
    )


def stable_proportionality(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many the stable proportionality across a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;stable_proportionality&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the stable proportionality across the
        elections.
    &#34;&#34;&#34;
    return Score(
        &#34;stable_proportionality&#34;,
        partial(_stable_proportionality, election_cols=election_cols, party=party)
    )


def efficiency_gap(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the efficiency gap metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;efficiency_gap&#34;`  and associated function that takes a partition
        and returns a PlanWideScoreValue for efficiency gap metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}efficiency_gap&#34;,
        partial(_efficiency_gap, election_cols=election_cols, mean=mean)
    )


def simplified_efficiency_gap(election_cols: Iterable[str], party: str, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the simplified efficiency gap metric of a plan with respect to a set of elections.
    The original formulation of efficiency gap quantifies the difference in &#34;wasted&#34; votes for the two
    parties across the state, as a share of votes cast. This is sensitive to turnout effects. The
    simplified score is equal to standard efficiency gap when the districts have equal turnout.
    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.
    Returns:
        A score object with name `&#34;efficiency_gap&#34;`  and associated function that takes a partition
        and returns a PlanWideScoreValue for efficiency gap metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}simplified_efficiency_gap&#34;,
        partial(
            _simplified_efficiency_gap, election_cols=election_cols, party=party, mean=mean
        )
    )


def mean_median(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the mean median metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;mean_median&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for the mean median metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}mean_median&#34;,
        partial(_mean_median, election_cols=election_cols, mean=mean)
    )


def partisan_bias(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the partitisan bias metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.
    Returns:
        A score object with name `&#34;partisan_bias&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for partisan bias metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}partisan_bias&#34;,
        partial(_partisan_bias, election_cols=election_cols, mean=mean)
    )


def partisan_gini(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the partisan gini metric of a plan with respect to a set
    of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections,
            or a dictionary of the score for each election.

    Returns:
        A score object with name `&#34;partisan_gini&#34;` and associated function that
        takes a partition and
        returns a PlanWideScoreValue for the partisan gini metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}partisan_gini&#34;,
        partial(_partisan_gini, election_cols=election_cols, mean=mean)
    )


def eguia(
    election_cols: Iterable[str], party: str, graph: Graph,
    updaters: Mapping[str, Callable[[Partition], ScoreValue]],
    county_col: str, totpop_col: str = &#34;population&#34;, mean: bool = False
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the Equia metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        graph (gerrychain.Graph): The underlying dual graph of a partition.  Used to generated a
            plan of the counties.
        updaters (Mapping[str, Callable[[gerrychain.Partition], ScoreValue]]):  A set of updaters
            that contains a tally for the total population by district and the election updaters
            whose names are listed in election_cols.
        county_col (str): The column name in the dual graph that encodes the county assignment of
            each unit.
        totpop_col (str, optional): The name of the updater that computes total population by
            district.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;eguia&#34;` and associated function that takes a partition and returns
        a PlanWideScoreValue for the eguia metric.
    &#34;&#34;&#34;
    county_part = Partition(graph, county_col, updaters=updaters)
    prefix = &#34;mean_&#34; if mean else &#34;&#34;

    return Score(
        f&#34;{prefix}eguia&#34;,
        partial(
            _eguia, election_cols=election_cols, party=party, county_part=county_part,
            totpop_col=totpop_col, mean=mean
        )
    )


def demographic_tallies(population_cols: Iterable[str]) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing population tallies.

    Args:
        population_cols (Iterable[str]): The population column to create tallies for.

    Returns:
        A list of score objects named by `&#34;{column}&#34;` and with associated functions that take a partition
        and return a DistrictWideScoreValue for the demographic totals of each district.
    &#34;&#34;&#34;
    return [
        Score(col, partial(_tally_pop, pop_col=col))
        for col in population_cols
    ]


def demographic_shares(population_cols: Mapping[str, Iterable[str]]) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing subgroup population shares.

    Args:
        population_cols (Mapping[str, Iterable[str]]): A mapping encoding the total population group
            divisor as well as the subgroups to create shares for.  The mapping has the format:
            { \\(P\\) : [ \\(P_1\\), \\(P_2\\), ..., \\(P_k\\)], ...} where \\(P\\) is the population and
            \\( P_i \\subseteq P \\) forall subgroups \\(P_i\\).

    Returns:
        A list of score objects named with the pattern `&#34;{column}_share&#34;` and with associated
        functions that take a partition and return a DistrictWideScoreValue for the demographic
        share of each district.
    &#34;&#34;&#34;
    scores = []

    for totalpop_col, subpop_cols in population_cols.items():
        scores.extend([
            Score(f&#34;{col}_share&#34;, partial(_pop_shares, subpop_col=col, totpop_col=totalpop_col))
            for col in subpop_cols
        ])
    return scores


def gingles_districts(population_cols: Mapping[str, Iterable[str]], threshold: float = 0.5) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing the number of districts where a sub-population share is above
    a given threshold.  When the threshold is 50% these are commonly called Gingles&#39; Districts.

    Args:
        population_cols (Mapping[str, Iterable[str]]): A mapping encoding the total population group
            divisor as well as the subgroups to create gingles district counters for.  The mapping
            has the format: `{ \\(P\\) : [ \\(P_1\\), \\(P_2\\), ..., \\(P_k\\)], ...}` where \\(P\\) is the
            population and \\( P_i \\subseteq P \\) forall subgroups \\(P_i\\).

    Returns:
        A list of score objects named with the pattern `&#34;{column}_gingles_districts&#34;` and with
        associated functions that take a partition and return a PlanWideScoreValue for the number of
        districts above the population share threshold.
    &#34;&#34;&#34;
    scores = []

    for totalpop_col, subpop_cols in population_cols.items():
        scores.extend([
            Score(f&#34;{col}_gingles_districts&#34;, partial(_gingles_districts, subpop_col=col,
                                                      totpop_col=totalpop_col, threshold=threshold))
            for col in subpop_cols
        ])
    return scores


def max_deviation(totpop_col: str, pct: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Returns the maximum deviation from ideal population size among all the districts.
    If `pct`, return the deviation as a percentage of ideal population size.

    Args:
        totpop_col (str, optional): The name of the updater that computes total population by
            district.
        pct (bool): Whether to return the maximum deviation as a count or as a percentage of
                    ideal district size.
    &#34;&#34;&#34;
    return Score(f&#34;{totpop_col}_max_deviation&#34;, partial(_max_deviation, totpop_col=totpop_col, pct=pct))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.scoring.scores.aggregate_seats"><code class="name flex">
<span>def <span class="ident">aggregate_seats</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many total seats (districts) within a given plan the POV party won across
elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"aggregate_{party}_seats"</code> and associated function that takes a
partition and returns an PlanWideScoreValue for the total number of seats won by the POV
party across elections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate_seats(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many total seats (districts) within a given plan the POV party won across
    elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;aggregate_{party}_seats&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the total number of seats won by the POV
        party across elections.
    &#34;&#34;&#34;
    return Score(
        f&#34;aggregate_{party}_seats&#34;,
        partial(_aggregate_seats, election_cols=election_cols, party=party)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.competitive_contests"><code class="name flex">
<span>def <span class="ident">competitive_contests</span></span>(<span>election_cols: Iterable[str], party: str, points_within: float = 0.03, alias: str = None) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of competitive contests in a plan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>points_within</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The margin from 0.5 that is considered competitive.
Default is 0.03, corresponding to a competitive range of 47%-53%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"competitive_contests_0.03"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of competitive districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def competitive_contests(
    election_cols: Iterable[str], party: str, points_within: float = 0.03,
    alias: str = None
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of competitive contests in a plan.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        points_within (float, optional): The margin from 0.5 that is considered competitive.
            Default is 0.03, corresponding to a competitive range of 47%-53%.

    Returns:
        A score object with name `&#34;competitive_contests_0.03&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of competitive districts.
    &#34;&#34;&#34;
    if alias is None:
        alias = f&#34;competitive_contests_{points_within}&#34;
    return Score(
        alias,
        partial(
            _competitive_contests, election_cols=election_cols, party=party,
            points_within=points_within
        )
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.demographic_shares"><code class="name flex">
<span>def <span class="ident">demographic_shares</span></span>(<span>population_cols: Mapping[str, Iterable[str]]) ‑> List[<a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A list of scores representing subgroup population shares.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population_cols</code></strong> :&ensp;<code>Mapping[str, Iterable[str]]</code></dt>
<dd>A mapping encoding the total population group
divisor as well as the subgroups to create shares for.
The mapping has the format:
{ <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> : [ <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>, <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span>, &hellip;, <span><span class="MathJax_Preview">P_k</span><script type="math/tex">P_k</script></span>], &hellip;} where <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> is the population and
<span><span class="MathJax_Preview"> P_i \subseteq P </span><script type="math/tex"> P_i \subseteq P </script></span> forall subgroups <span><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of score objects named with the pattern <code>"{column}_share"</code> and with associated
functions that take a partition and return a DistrictWideScoreValue for the demographic
share of each district.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demographic_shares(population_cols: Mapping[str, Iterable[str]]) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing subgroup population shares.

    Args:
        population_cols (Mapping[str, Iterable[str]]): A mapping encoding the total population group
            divisor as well as the subgroups to create shares for.  The mapping has the format:
            { \\(P\\) : [ \\(P_1\\), \\(P_2\\), ..., \\(P_k\\)], ...} where \\(P\\) is the population and
            \\( P_i \\subseteq P \\) forall subgroups \\(P_i\\).

    Returns:
        A list of score objects named with the pattern `&#34;{column}_share&#34;` and with associated
        functions that take a partition and return a DistrictWideScoreValue for the demographic
        share of each district.
    &#34;&#34;&#34;
    scores = []

    for totalpop_col, subpop_cols in population_cols.items():
        scores.extend([
            Score(f&#34;{col}_share&#34;, partial(_pop_shares, subpop_col=col, totpop_col=totalpop_col))
            for col in subpop_cols
        ])
    return scores</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.demographic_tallies"><code class="name flex">
<span>def <span class="ident">demographic_tallies</span></span>(<span>population_cols: Iterable[str]) ‑> List[<a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A list of scores representing population tallies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The population column to create tallies for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of score objects named by <code>"{column}"</code> and with associated functions that take a partition
and return a DistrictWideScoreValue for the demographic totals of each district.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demographic_tallies(population_cols: Iterable[str]) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing population tallies.

    Args:
        population_cols (Iterable[str]): The population column to create tallies for.

    Returns:
        A list of score objects named by `&#34;{column}&#34;` and with associated functions that take a partition
        and return a DistrictWideScoreValue for the demographic totals of each district.
    &#34;&#34;&#34;
    return [
        Score(col, partial(_tally_pop, pop_col=col))
        for col in population_cols
    ]</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.efficiency_gap"><code class="name flex">
<span>def <span class="ident">efficiency_gap</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the efficiency gap metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"efficiency_gap"</code>
and associated function that takes a partition
and returns a PlanWideScoreValue for efficiency gap metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficiency_gap(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the efficiency gap metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;efficiency_gap&#34;`  and associated function that takes a partition
        and returns a PlanWideScoreValue for efficiency gap metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}efficiency_gap&#34;,
        partial(_efficiency_gap, election_cols=election_cols, mean=mean)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.eguia"><code class="name flex">
<span>def <span class="ident">eguia</span></span>(<span>election_cols: Iterable[str], party: str, graph: gerrychain.graph.graph.Graph, updaters: Mapping[str, Callable[[gerrychain.partition.partition.Partition], Union[float, int, Mapping[Union[int, str], Union[float, int]], Mapping[str, Union[float, int]]]]], county_col: str, totpop_col: str = 'population', mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the Equia metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>graph</code></strong> :&ensp;<code>gerrychain.Graph</code></dt>
<dd>The underlying dual graph of a partition.
Used to generated a
plan of the counties.</dd>
<dt><strong><code>updaters</code></strong> :&ensp;<code>Mapping[str, Callable[[gerrychain.Partition], ScoreValue]]</code></dt>
<dd>A set of updaters
that contains a tally for the total population by district and the election updaters
whose names are listed in election_cols.</dd>
<dt><strong><code>county_col</code></strong> :&ensp;<code>str</code></dt>
<dd>The column name in the dual graph that encodes the county assignment of
each unit.</dd>
<dt><strong><code>totpop_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the updater that computes total population by
district.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"eguia"</code> and associated function that takes a partition and returns
a PlanWideScoreValue for the eguia metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eguia(
    election_cols: Iterable[str], party: str, graph: Graph,
    updaters: Mapping[str, Callable[[Partition], ScoreValue]],
    county_col: str, totpop_col: str = &#34;population&#34;, mean: bool = False
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the Equia metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        graph (gerrychain.Graph): The underlying dual graph of a partition.  Used to generated a
            plan of the counties.
        updaters (Mapping[str, Callable[[gerrychain.Partition], ScoreValue]]):  A set of updaters
            that contains a tally for the total population by district and the election updaters
            whose names are listed in election_cols.
        county_col (str): The column name in the dual graph that encodes the county assignment of
            each unit.
        totpop_col (str, optional): The name of the updater that computes total population by
            district.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;eguia&#34;` and associated function that takes a partition and returns
        a PlanWideScoreValue for the eguia metric.
    &#34;&#34;&#34;
    county_part = Partition(graph, county_col, updaters=updaters)
    prefix = &#34;mean_&#34; if mean else &#34;&#34;

    return Score(
        f&#34;{prefix}eguia&#34;,
        partial(
            _eguia, election_cols=election_cols, party=party, county_part=county_part,
            totpop_col=totpop_col, mean=mean
        )
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.gingles_districts"><code class="name flex">
<span>def <span class="ident">gingles_districts</span></span>(<span>population_cols: Mapping[str, Iterable[str]], threshold: float = 0.5) ‑> List[<a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A list of scores representing the number of districts where a sub-population share is above
a given threshold.
When the threshold is 50% these are commonly called Gingles' Districts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population_cols</code></strong> :&ensp;<code>Mapping[str, Iterable[str]]</code></dt>
<dd>A mapping encoding the total population group
divisor as well as the subgroups to create gingles district counters for.
The mapping
has the format: <code>{ \(P\) : [ \(P_1\), \(P_2\), ..., \(P_k\)], ...}</code> where <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> is the
population and <span><span class="MathJax_Preview"> P_i \subseteq P </span><script type="math/tex"> P_i \subseteq P </script></span> forall subgroups <span><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of score objects named with the pattern <code>"{column}_gingles_districts"</code> and with
associated functions that take a partition and return a PlanWideScoreValue for the number of
districts above the population share threshold.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gingles_districts(population_cols: Mapping[str, Iterable[str]], threshold: float = 0.5) -&gt; List[Score]:
    &#34;&#34;&#34;
    A list of scores representing the number of districts where a sub-population share is above
    a given threshold.  When the threshold is 50% these are commonly called Gingles&#39; Districts.

    Args:
        population_cols (Mapping[str, Iterable[str]]): A mapping encoding the total population group
            divisor as well as the subgroups to create gingles district counters for.  The mapping
            has the format: `{ \\(P\\) : [ \\(P_1\\), \\(P_2\\), ..., \\(P_k\\)], ...}` where \\(P\\) is the
            population and \\( P_i \\subseteq P \\) forall subgroups \\(P_i\\).

    Returns:
        A list of score objects named with the pattern `&#34;{column}_gingles_districts&#34;` and with
        associated functions that take a partition and return a PlanWideScoreValue for the number of
        districts above the population share threshold.
    &#34;&#34;&#34;
    scores = []

    for totalpop_col, subpop_cols in population_cols.items():
        scores.extend([
            Score(f&#34;{col}_gingles_districts&#34;, partial(_gingles_districts, subpop_col=col,
                                                      totpop_col=totalpop_col, threshold=threshold))
            for col in subpop_cols
        ])
    return scores</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.max_deviation"><code class="name flex">
<span>def <span class="ident">max_deviation</span></span>(<span>totpop_col: str, pct: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum deviation from ideal population size among all the districts.
If <code>pct</code>, return the deviation as a percentage of ideal population size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>totpop_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the updater that computes total population by
district.</dd>
<dt><strong><code>pct</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the maximum deviation as a count or as a percentage of
ideal district size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_deviation(totpop_col: str, pct: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Returns the maximum deviation from ideal population size among all the districts.
    If `pct`, return the deviation as a percentage of ideal population size.

    Args:
        totpop_col (str, optional): The name of the updater that computes total population by
            district.
        pct (bool): Whether to return the maximum deviation as a count or as a percentage of
                    ideal district size.
    &#34;&#34;&#34;
    return Score(f&#34;{totpop_col}_max_deviation&#34;, partial(_max_deviation, totpop_col=totpop_col, pct=pct))</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.mean_median"><code class="name flex">
<span>def <span class="ident">mean_median</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the mean median metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"mean_median"</code> and associated function that takes a partition and
returns a PlanWideScoreValue for the mean median metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_median(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the mean median metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;mean_median&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for the mean median metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}mean_median&#34;,
        partial(_mean_median, election_cols=election_cols, mean=mean)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.opp_party_districts"><code class="name flex">
<span>def <span class="ident">opp_party_districts</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of districts in a plan that are always won by the opposition party
over a set of elections.
Note that this assumes that all elections are two-party races.
In the case where elections have
more than two parties running this score represents the number of districts that are never won
by the POV party.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"opp_party_districts"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of safe opposition party districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opp_party_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of districts in a plan that are always won by the opposition party
    over a set of elections.
    Note that this assumes that all elections are two-party races.  In the case where elections have
    more than two parties running this score represents the number of districts that are never won
    by the POV party.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;opp_party_districts&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of safe opposition party districts.
    &#34;&#34;&#34;
    return Score(
        &#34;opp_party_districts&#34;,
        partial(_opp_party_districts, election_cols=election_cols, party=party)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.partisan_bias"><code class="name flex">
<span>def <span class="ident">partisan_bias</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the partitisan bias metric of a plan with respect to a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"partisan_bias"</code> and associated function that takes a partition and
returns a PlanWideScoreValue for partisan bias metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partisan_bias(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the partitisan bias metric of a plan with respect to a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.
    Returns:
        A score object with name `&#34;partisan_bias&#34;` and associated function that takes a partition and
        returns a PlanWideScoreValue for partisan bias metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}partisan_bias&#34;,
        partial(_partisan_bias, election_cols=election_cols, mean=mean)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.partisan_gini"><code class="name flex">
<span>def <span class="ident">partisan_gini</span></span>(<span>election_cols: Iterable[str], mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the partisan gini metric of a plan with respect to a set
of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections,
or a dictionary of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"partisan_gini"</code> and associated function that
takes a partition and
returns a PlanWideScoreValue for the partisan gini metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partisan_gini(election_cols: Iterable[str], mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the partisan gini metric of a plan with respect to a set
    of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections,
            or a dictionary of the score for each election.

    Returns:
        A score object with name `&#34;partisan_gini&#34;` and associated function that
        takes a partition and
        returns a PlanWideScoreValue for the partisan gini metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}partisan_gini&#34;,
        partial(_partisan_gini, election_cols=election_cols, mean=mean)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.party_districts"><code class="name flex">
<span>def <span class="ident">party_districts</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of districts in a plan that are always won by the POV party over
a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"party_districts"</code> and associated function that takes a partition
and returns a PlanWideScoreValue for the number of safe POV party districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def party_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of districts in a plan that are always won by the POV party over
    a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;party_districts&#34;` and associated function that takes a partition
        and returns a PlanWideScoreValue for the number of safe POV party districts.
    &#34;&#34;&#34;
    return Score(
        &#34;party_districts&#34;,
        partial(_party_districts, election_cols=election_cols, party=party)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.party_wins_by_district"><code class="name flex">
<span>def <span class="ident">party_wins_by_district</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many elections the POV party won in each district in a given plan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"party_wins_by_district"</code> and associated function that takes a
partition and returns a DistrictWideScoreValue for the number of elections won by the POV
party in each district.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def party_wins_by_district(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many elections the POV party won in each district in a given plan.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;party_wins_by_district&#34;` and associated function that takes a
        partition and returns a DistrictWideScoreValue for the number of elections won by the POV
        party in each district.
    &#34;&#34;&#34;
    return Score(
        &#34;party_wins_by_district&#34;,
        partial(_party_wins_by_district, election_cols=election_cols, party=party)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.pieces"><code class="name flex">
<span>def <span class="ident">pieces</span></span>(<span>unit: str, names: bool = False, popcol: str = None, how: str = 'pandas', alias: str = None) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of "unit pieces" produced by the plan. For example,
consider a state with 100 counties. Suppose that one county is split twice,
and another once. Then, there are 3 + 2 = 5 "pieces," disregarding the
counties kept whole.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Data column; each assigns a vertex to a unit.
Generally, these units are counties, VTDs, precincts, etc.</dd>
<dt><strong><code>popcol</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The population column on the <code>Partition</code>'s dual
graph. If this is passed, then a unit is only considered "split" if
the <em>populated</em> base units end up in different districts.</dd>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>How do we perform these calculations on the back
end? Acceptable values are <code>"pandas"</code> and <code>"gerrychain"</code>; defaults to
<code>"pandas"</code>.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether we return the identifiers of the things
being split.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with the name <code>"{alias}_pieces"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of pieces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pieces(
    unit: str, names: bool = False, popcol: str = None, how: str = &#34;pandas&#34;,
    alias: str = None
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of &#34;unit pieces&#34; produced by the plan. For example,
    consider a state with 100 counties. Suppose that one county is split twice,
    and another once. Then, there are 3 + 2 = 5 &#34;pieces,&#34; disregarding the
    counties kept whole.

    Bear in mind that this calculates the number of _unit splits_, not the number
    of _units split_: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county
    being split).

    Args:
        unit (str): Data column; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        popcol (str, optional): The population column on the `Partition`&#39;s dual
            graph. If this is passed, then a unit is only considered &#34;split&#34; if
            the _populated_ base units end up in different districts.
        how (str, optional): How do we perform these calculations on the back
            end? Acceptable values are `&#34;pandas&#34;` and `&#34;gerrychain&#34;`; defaults to
            `&#34;pandas&#34;`.
        names (bool, optional): Whether we return the identifiers of the things
            being split.

    Returns:
        A score object with the name `&#34;{alias}_pieces&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of pieces.
    &#34;&#34;&#34;
    if alias is None:
        alias = unit

    return Score(
        f&#34;{alias}_pieces&#34;,
        partial(_pieces, unit=unit, how=how, popcol=popcol, names=names)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.responsive_proportionality"><code class="name flex">
<span>def <span class="ident">responsive_proportionality</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many the responsive proportionality across a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"responsive_proportionality"</code> and associated function that takes a
partition and returns an PlanWideScoreValue for the responsive proportionality across the
elections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def responsive_proportionality(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many the responsive proportionality across a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;responsive_proportionality&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the responsive proportionality across the
        elections.
    &#34;&#34;&#34;
    return Score(
        &#34;responsive_proportionality&#34;,
        partial(
            _responsive_proportionality, election_cols=election_cols, party=party
        )
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.seats"><code class="name flex">
<span>def <span class="ident">seats</span></span>(<span>election_cols: Iterable[str], party: str, mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many seats (districts) within a given plan the POV party won in each
election</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"{party}_seats"</code> and associated function that takes a partition and
returns an ElectionWideScoreValue for the number of seats won by the POV party for each
election.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seats(election_cols: Iterable[str], party: str, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many seats (districts) within a given plan the POV party won in each
    election

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.

    Returns:
        A score object with name `&#34;{party}_seats&#34;` and associated function that takes a partition and
        returns an ElectionWideScoreValue for the number of seats won by the POV party for each
        election.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}{party}_seats&#34;,
        partial(_seats, election_cols=election_cols, party=party, mean=mean)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.simplified_efficiency_gap"><code class="name flex">
<span>def <span class="ident">simplified_efficiency_gap</span></span>(<span>election_cols: Iterable[str], party: str, mean: bool = False) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the simplified efficiency gap metric of a plan with respect to a set of elections.
The original formulation of efficiency gap quantifies the difference in "wasted" votes for the two
parties across the state, as a share of votes cast. This is sensitive to turnout effects. The
simplified score is equal to standard efficiency gap when the districts have equal turnout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the mean of the score over all elections, or a dictionary
of the score for each election.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"efficiency_gap"</code>
and associated function that takes a partition
and returns a PlanWideScoreValue for efficiency gap metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplified_efficiency_gap(election_cols: Iterable[str], party: str, mean: bool = False) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the simplified efficiency gap metric of a plan with respect to a set of elections.
    The original formulation of efficiency gap quantifies the difference in &#34;wasted&#34; votes for the two
    parties across the state, as a share of votes cast. This is sensitive to turnout effects. The
    simplified score is equal to standard efficiency gap when the districts have equal turnout.
    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.
        mean (bool): Whether to return the mean of the score over all elections, or a dictionary
                     of the score for each election.
    Returns:
        A score object with name `&#34;efficiency_gap&#34;`  and associated function that takes a partition
        and returns a PlanWideScoreValue for efficiency gap metric.
    &#34;&#34;&#34;
    prefix = &#34;mean_&#34; if mean else &#34;&#34;
    return Score(
        f&#34;{prefix}simplified_efficiency_gap&#34;,
        partial(
            _simplified_efficiency_gap, election_cols=election_cols, party=party, mean=mean
        )
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.splits"><code class="name flex">
<span>def <span class="ident">splits</span></span>(<span>unit: str, names: bool = False, popcol: str = None, how: str = 'pandas', alias: str = None) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of units split by the districting plan.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Data column; each assigns a vertex to a unit.
Generally, these units are counties, VTDs, precincts, etc.</dd>
<dt><strong><code>popcol</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The population column on the <code>Partition</code>'s dual
graph. If this is passed, then a unit is only considered "split" if
the <em>populated</em> base units end up in different districts.</dd>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>How do we perform these calculations on the back
end? Acceptable values are <code>"pandas"</code> and <code>"gerrychain"</code>; defaults to
<code>"pandas"</code>.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether we return the identifiers of the things
being split.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with the name <code>"{alias}_splits"</code> and associated function that takes a
partition and returns a PlanWideScoreValue for the number of splits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splits(
    unit: str, names: bool = False, popcol: str = None, how: str = &#34;pandas&#34;,
    alias: str = None
) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of units split by the districting plan.

    Bear in mind that this calculates the number of *unit splits*, not the number
    of *units split*: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county
    being split).

    Args:
        unit (str): Data column; each assigns a vertex to a unit.
            Generally, these units are counties, VTDs, precincts, etc.
        popcol (str, optional): The population column on the `Partition`&#39;s dual
            graph. If this is passed, then a unit is only considered &#34;split&#34; if
            the _populated_ base units end up in different districts.
        how (str, optional): How do we perform these calculations on the back
            end? Acceptable values are `&#34;pandas&#34;` and `&#34;gerrychain&#34;`; defaults to
            `&#34;pandas&#34;`.
        names (bool, optional): Whether we return the identifiers of the things
            being split.

    Returns:
        A score object with the name `&#34;{alias}_splits&#34;` and associated function that takes a
        partition and returns a PlanWideScoreValue for the number of splits.
    &#34;&#34;&#34;
    if alias is None:
        alias = unit

    return Score(
        f&#34;{alias}_splits&#34;,
        partial(_splits, unit=unit, how=how, popcol=popcol, names=names)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.stable_proportionality"><code class="name flex">
<span>def <span class="ident">stable_proportionality</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing how many the stable proportionality across a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"stable_proportionality"</code> and associated function that takes a
partition and returns an PlanWideScoreValue for the stable proportionality across the
elections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stable_proportionality(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing how many the stable proportionality across a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;stable_proportionality&#34;` and associated function that takes a
        partition and returns an PlanWideScoreValue for the stable proportionality across the
        elections.
    &#34;&#34;&#34;
    return Score(
        &#34;stable_proportionality&#34;,
        partial(_stable_proportionality, election_cols=election_cols, party=party)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>part: gerrychain.partition.partition.Partition, scores: Iterable[<a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a>]) ‑> Dict[str, Union[float, int, Mapping[Union[int, str], Union[float, int]], Mapping[str, Union[float, int]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Summarize the given partition by the passed scores.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>part</code></strong> :&ensp;<code>Partition</code></dt>
<dd>The plan to summarize.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>Iterable[Score]</code></dt>
<dd>Which scores to include in the summary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that maps score names to the corresponding ScoreValues of the score functions
applied to the plan.</p>
<p>ie.
<code>{"cut_edges": 4050, "num_party_seats": 3, ... }</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(part: Partition, scores: Iterable[Score]) -&gt; Dict[str, ScoreValue]:
    &#34;&#34;&#34;
    Summarize the given partition by the passed scores.

    Args:
        part (Partition): The plan to summarize.
        scores (Iterable[Score]): Which scores to include in the summary.

    Returns:
        A dictionary that maps score names to the corresponding ScoreValues of the score functions
        applied to the plan.

        ie.
        `{&#34;cut_edges&#34;: 4050, &#34;num_party_seats&#34;: 3, ... }`
    &#34;&#34;&#34;
    summary = {}
    for score in scores:
        summary[score.name] = score.apply(part)
    return summary</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.summarize_many"><code class="name flex">
<span>def <span class="ident">summarize_many</span></span>(<span>parts: Iterable[gerrychain.partition.partition.Partition], scores: Iterable[<a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a>], plan_names: List[str] = [], output_file: str = None, compress: bool = False, verbose: bool = False) ‑> Optional[List[Dict[str, Union[float, int, Mapping[Union[int, str], Union[float, int]], Mapping[str, Union[float, int]]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Summarize the given partitions by the passed scores.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parts</code></strong> :&ensp;<code>Iterable[Partition]</code></dt>
<dd>The plans to summarize.</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>Iterable[Score]</code></dt>
<dd>Which scores to include in the summaries.</dd>
<dt><strong><code>plan_names</code></strong> :&ensp;<code>Iterable[str]</code>, optional</dt>
<dd>Plan identifiers, corresponding to
plan by index. If no plan name exists for a given plan's index, the
plan's index is used as the identifier. Default is <code>[]</code>, plans
identified by index.</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of file to save the results jsonl
encoding of the scores. If None, returns a list of the dictionary
summary of each plan. Defaults to None.</dd>
<dt><strong><code>compress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to compress the output file with gzip.
Default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list dictionaries that maps score names to the corresponding ScoreValues
of the score functions applied to each plan, if NO output file is passed.
If an output file IS specified, the plan summaries are written to file
and the function is void.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize_many(
    parts: Iterable[Partition], scores: Iterable[Score], plan_names: List[str] = [],
    output_file: str = None, compress: bool = False, verbose: bool = False
) -&gt; Union[List[Dict[str, ScoreValue]], None]:
    &#34;&#34;&#34;
    Summarize the given partitions by the passed scores.

    Args:
        parts (Iterable[Partition]): The plans to summarize.
        scores (Iterable[Score]): Which scores to include in the summaries.
        plan_names (Iterable[str], optional): Plan identifiers, corresponding to
            plan by index. If no plan name exists for a given plan&#39;s index, the
            plan&#39;s index is used as the identifier. Default is `[]`, plans
            identified by index.
        output_file (str, optional): Name of file to save the results jsonl
            encoding of the scores. If None, returns a list of the dictionary
            summary of each plan. Defaults to None.
        compress (bool, optional): Whether to compress the output file with gzip.
            Default is False.

    Returns:
        A list dictionaries that maps score names to the corresponding ScoreValues
        of the score functions applied to each plan, if NO output file is passed.
        If an output file IS specified, the plan summaries are written to file
        and the function is void.
    &#34;&#34;&#34;
    if output_file is None:
        if verbose:
            result = []
            for part in tqdm(parts):
                result.append(summarize(part, scores=scores))
            return result
        return [summarize(part, scores=scores) for part in parts]
    else:
        with gzip.open(f&#34;{output_file}.gz&#34;, &#34;wt&#34;) if compress else open(output_file, &#34;w&#34;) as fout:
            iterator = tqdm(enumerate(parts)) if verbose else enumerate(parts)
            for i, part in iterator:
                plan_details = summarize(part, scores=scores)
                try:
                    plan_details[&#34;id&#34;] = plan_names[i]
                except BaseException:
                    plan_details[&#34;id&#34;] = i
                fout.write(json.dumps(plan_details) + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="evaltools.scoring.scores.swing_districts"><code class="name flex">
<span>def <span class="ident">swing_districts</span></span>(<span>election_cols: Iterable[str], party: str) ‑> <a title="evaltools.scoring.types.Score" href="types.html#evaltools.scoring.types.Score">Score</a></span>
</code></dt>
<dd>
<div class="desc"><p>Score representing the number of swing districts in a plan.
A swing districts is one that is
not solely won by a single party over a set of elections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>election_cols</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The names of the election updaters over which to compute
results for.</dd>
<dt><strong><code>party</code></strong> :&ensp;<code>str</code></dt>
<dd>The "point of view" political party.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A score object with name <code>"swing_districts"</code> and associated function that takes a partition
and returns a PlanWideScoreValue for the number of swing districts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swing_districts(election_cols: Iterable[str], party: str) -&gt; Score:
    &#34;&#34;&#34;
    Score representing the number of swing districts in a plan.  A swing districts is one that is
    not solely won by a single party over a set of elections.

    Args:
        election_cols (Iterable[str]): The names of the election updaters over which to compute
            results for.
        party (str): The &#34;point of view&#34; political party.

    Returns:
        A score object with name `&#34;swing_districts&#34;` and associated function that takes a partition
        and returns a PlanWideScoreValue for the number of swing districts.
    &#34;&#34;&#34;
    return Score(
        &#34;swing_districts&#34;,
        partial(_swing_districts, election_cols=election_cols, party=party)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="evaltools" href="https://github.com/mggg/plan-evaluation-processing">
<style>
header > h1 { display: none; }
img.resize {
max-width: 80%;
max-height: 80%;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
</style>
<img class="resize" src="https://mggg.org/assets/logo.svg" alt="MGGG Logo">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="evaltools.scoring" href="index.html">evaltools.scoring</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="evaltools.scoring.scores.aggregate_seats" href="#evaltools.scoring.scores.aggregate_seats">aggregate_seats</a></code></li>
<li><code><a title="evaltools.scoring.scores.competitive_contests" href="#evaltools.scoring.scores.competitive_contests">competitive_contests</a></code></li>
<li><code><a title="evaltools.scoring.scores.demographic_shares" href="#evaltools.scoring.scores.demographic_shares">demographic_shares</a></code></li>
<li><code><a title="evaltools.scoring.scores.demographic_tallies" href="#evaltools.scoring.scores.demographic_tallies">demographic_tallies</a></code></li>
<li><code><a title="evaltools.scoring.scores.efficiency_gap" href="#evaltools.scoring.scores.efficiency_gap">efficiency_gap</a></code></li>
<li><code><a title="evaltools.scoring.scores.eguia" href="#evaltools.scoring.scores.eguia">eguia</a></code></li>
<li><code><a title="evaltools.scoring.scores.gingles_districts" href="#evaltools.scoring.scores.gingles_districts">gingles_districts</a></code></li>
<li><code><a title="evaltools.scoring.scores.max_deviation" href="#evaltools.scoring.scores.max_deviation">max_deviation</a></code></li>
<li><code><a title="evaltools.scoring.scores.mean_median" href="#evaltools.scoring.scores.mean_median">mean_median</a></code></li>
<li><code><a title="evaltools.scoring.scores.opp_party_districts" href="#evaltools.scoring.scores.opp_party_districts">opp_party_districts</a></code></li>
<li><code><a title="evaltools.scoring.scores.partisan_bias" href="#evaltools.scoring.scores.partisan_bias">partisan_bias</a></code></li>
<li><code><a title="evaltools.scoring.scores.partisan_gini" href="#evaltools.scoring.scores.partisan_gini">partisan_gini</a></code></li>
<li><code><a title="evaltools.scoring.scores.party_districts" href="#evaltools.scoring.scores.party_districts">party_districts</a></code></li>
<li><code><a title="evaltools.scoring.scores.party_wins_by_district" href="#evaltools.scoring.scores.party_wins_by_district">party_wins_by_district</a></code></li>
<li><code><a title="evaltools.scoring.scores.pieces" href="#evaltools.scoring.scores.pieces">pieces</a></code></li>
<li><code><a title="evaltools.scoring.scores.responsive_proportionality" href="#evaltools.scoring.scores.responsive_proportionality">responsive_proportionality</a></code></li>
<li><code><a title="evaltools.scoring.scores.seats" href="#evaltools.scoring.scores.seats">seats</a></code></li>
<li><code><a title="evaltools.scoring.scores.simplified_efficiency_gap" href="#evaltools.scoring.scores.simplified_efficiency_gap">simplified_efficiency_gap</a></code></li>
<li><code><a title="evaltools.scoring.scores.splits" href="#evaltools.scoring.scores.splits">splits</a></code></li>
<li><code><a title="evaltools.scoring.scores.stable_proportionality" href="#evaltools.scoring.scores.stable_proportionality">stable_proportionality</a></code></li>
<li><code><a title="evaltools.scoring.scores.summarize" href="#evaltools.scoring.scores.summarize">summarize</a></code></li>
<li><code><a title="evaltools.scoring.scores.summarize_many" href="#evaltools.scoring.scores.summarize_many">summarize_many</a></code></li>
<li><code><a title="evaltools.scoring.scores.swing_districts" href="#evaltools.scoring.scores.swing_districts">swing_districts</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>