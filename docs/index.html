<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>evaltools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>evaltools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .mapping import drawplan, drawgraph
from .colors import districtr, redblue
from .geography import dissolve, dualgraph
from .auxiliary import Graph, Partition
from .evaluation import (
    splits, pieces, deviations, ensemble_schema, assignment_schema,
    contiguous, unassigned
)

__all__ = [
    &#34;districtr&#34;, &#34;redblue&#34;, &#34;drawplan&#34;, &#34;dualgraph&#34;, &#34;dissolve&#34;,
    &#34;drawgraph&#34;, &#34;Graph&#34;, &#34;Partition&#34;, &#34;splits&#34;, &#34;pieces&#34;, &#34;deviations&#34;,
    &#34;ensemble_schema&#34;, &#34;assignment_schema&#34;, &#34;contiguous&#34;, &#34;unassigned&#34;
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="evaltools.auxiliary" href="auxiliary/index.html">evaltools.auxiliary</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.colors" href="colors.html">evaltools.colors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.evaluation" href="evaluation/index.html">evaltools.evaluation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.geography" href="geography/index.html">evaltools.geography</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="evaltools.mapping" href="mapping/index.html">evaltools.mapping</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="evaltools.contiguous"><code class="name flex">
<span>def <span class="ident">contiguous</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the parts of a partition are connected using :func:<code>networkx.is_connected</code>.</p>
<p>:param partition: The proposed next :class:<code>~gerrychain.partition.Partition</code></p>
<p>:return: whether the partition is contiguous
:rtype: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contiguous(partition):
    &#34;&#34;&#34;Check if the parts of a partition are connected using :func:`networkx.is_connected`.

    :param partition: The proposed next :class:`~gerrychain.partition.Partition`

    :return: whether the partition is contiguous
    :rtype: bool
    &#34;&#34;&#34;
    return all(
        nx.is_connected(partition.subgraphs[part]) for part in affected_parts(partition)
    )</code></pre>
</details>
</dd>
<dt id="evaltools.deviations"><code class="name flex">
<span>def <span class="ident">deviations</span></span>(<span>P: gerrychain.partition.partition.Partition, popcolumn: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the districting plan's population deviation percentages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong></dt>
<dd><code><a title="evaltools.Partition" href="#evaltools.Partition">Partition</a></code> object.</dd>
<dt><strong><code>popcolumn</code></strong></dt>
<dd>Column for tallying the desired population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary which maps district names to population deviation percentages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deviations(P:Partition, popcolumn:str) -&gt; dict:
    &#34;&#34;&#34;
    Determines the districting plan&#39;s population deviation percentages.
    
    Args:
        P: `Partition` object.
        popcolumn: Column for tallying the desired population.

    Returns:
        A dictionary which maps district names to population deviation percentages.
    &#34;&#34;&#34;
    # Create the partition and the corresponding updater.
    poptally = Tally(popcolumn, alias=popcolumn)
    P.updaters = { popcolumn: poptally }

    # Return a dictionary that maps district names to population deviation
    # percentages.
    return deviation(P, attribute=popcolumn)</code></pre>
</details>
</dd>
<dt id="evaltools.dissolve"><code class="name flex">
<span>def <span class="ident">dissolve</span></span>(<span>geometries, by='DISTRICTN', reset_index=True, keep=[], aggfunc='sum')</span>
</code></dt>
<dd>
<div class="desc"><p>Dissolves <code>geometries</code> on the column <code>by</code>. Intended to dissolve a set of
source geometries (e.g. VTDs, blocks, block groups, etc.) to district
geometries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometries</code></strong></dt>
<dd>Set of geometries to be dissolved.</dd>
<dt><strong><code>by</code></strong></dt>
<dd>Name of the column used to group objects.</dd>
<dt><strong><code>reset_index</code></strong></dt>
<dd>Optional; if true, the index of the resulting GeoDataFrame
will be set to an integer index, not <code>by</code>. </dd>
<dt><strong><code>keep</code></strong></dt>
<dd>Additional columns to keep beyond the geometry and <code>by</code> columns.</dd>
<dt><strong><code>aggfunc</code></strong></dt>
<dd>Pandas groupby function type when aggregating; defaults to <code>"sum"</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>GeoDataFrame</code> containing dissolved geometries and kept columns
computed by the function designated by <code>aggfunc</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dissolve(geometries, by=&#34;DISTRICTN&#34;, reset_index=True, keep=[],aggfunc=&#34;sum&#34;):
    &#34;&#34;&#34;
    Dissolves `geometries` on the column `by`. Intended to dissolve a set of
    source geometries (e.g. VTDs, blocks, block groups, etc.) to district
    geometries.

    Args:
        geometries: Set of geometries to be dissolved.
        by: Name of the column used to group objects.
        reset_index: Optional; if true, the index of the resulting GeoDataFrame
            will be set to an integer index, not `by`. 
        keep: Additional columns to keep beyond the geometry and `by` columns.
        aggfunc: Pandas groupby function type when aggregating; defaults to `&#34;sum&#34;`.

    Returns:
        A `GeoDataFrame` containing dissolved geometries and kept columns
        computed by the function designated by `aggfunc`.
    &#34;&#34;&#34;
    # Pare down the geometries and dissolve.
    geometries = geometries[keep + [by, &#34;geometry&#34;]]
    geometries = geometries.dissolve(by=by, aggfunc=aggfunc)
    if reset_index: geometries = geometries.reset_index()

    return geometries</code></pre>
</details>
</dd>
<dt id="evaltools.drawgraph"><code class="name flex">
<span>def <span class="ident">drawgraph</span></span>(<span>G, ax=None, x='INTPTLON20', y='INTPTLAT20', components=False, node_size=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a gerrychain Graph object. Returns a single Axes object (for dual
graphs drawn whole) and lists of <code>(Figure, Axes)</code> pairs for graphs drawn
component-wise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>G</code></strong></dt>
<dd>The dual graph to draw.</dd>
<dt><strong><code>ax</code></strong></dt>
<dd>Optional; <code>matplotlib.axes.Axes</code> object. If not passed, one is created.</dd>
<dt><strong><code>x</code></strong></dt>
<dd>Optional; vertex property used as the horizontal (E-W) coordinate.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Optional; vertex property used as the vertical (N-S) coordinate.</dd>
<dt><strong><code>components</code></strong></dt>
<dd>Optional; if <code>True</code>, the graph is assumed to have more than
one connected component (e.g. Michigan) and is drawn component-wise
and rather than return a single <code>Axes</code> object, return a list of
<code>(Figure, Axes)</code> pairs. If something is passed to <code>ax</code>, the same
Axes instance is used for each new Figure.</dd>
<dt><strong><code>node_size</code></strong></dt>
<dd>Optional; specifies the default size of a vertex.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Optional; arguments to be passed to <code>nx.draw()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of <code>matplotlib</code> <code>(Figure, Axes)</code> objects, or if <code>components</code> is
<code>True</code>, returns a list of <code>(Figure, Axes)</code> objects corresponding to each
component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawgraph(
        G, ax=None, x=&#34;INTPTLON20&#34;, y=&#34;INTPTLAT20&#34;, components=False, node_size=1,
        **kwargs
    ):
    &#34;&#34;&#34;
    Draws a gerrychain Graph object. Returns a single Axes object (for dual
    graphs drawn whole) and lists of `(Figure, Axes)` pairs for graphs drawn
    component-wise.

    Args:
        G: The dual graph to draw.
        ax: Optional; `matplotlib.axes.Axes` object. If not passed, one is created.
        x: Optional; vertex property used as the horizontal (E-W) coordinate.
        y: Optional; vertex property used as the vertical (N-S) coordinate.
        components: Optional; if `True`, the graph is assumed to have more than
            one connected component (e.g. Michigan) and is drawn component-wise
            and rather than return a single `Axes` object, return a list of
            `(Figure, Axes)` pairs. If something is passed to `ax`, the same
            Axes instance is used for each new Figure.
        node_size: Optional; specifies the default size of a vertex.
        kwargs: Optional; arguments to be passed to `nx.draw()`.

    Returns:
        A tuple of `matplotlib` `(Figure, Axes)` objects, or if `components` is
        `True`, returns a list of `(Figure, Axes)` objects corresponding to each
        component.
    &#34;&#34;&#34;
    # Create a mapping from identifiers to positions.
    positions = {
        v: (properties[x], properties[y])
        for v, properties in G.nodes(data=True)
    }

    # If `components` is true, plot the graph component-wise. Otherwise plot
    # normally. First, set some properties common to both graphs.
    properties = {&#34;pos&#34;: positions, &#34;node_size&#34;: node_size }

    # Initialize `pairs` to None.
    pairs = None

    if not components:
        if not ax: axes = plt.axes()
        else: axes = ax
        nx.draw(G, ax=axes, **properties, **kwargs)
    else:
        # Create lists for figures and axes.
        pairs = []

        connected_components = [c for c in nx.connected_components(G)]
        for component in connected_components:
            # Create a new Figure object for each component.
            fig = plt.figure()
            if not ax: ax = plt.axes()

            # Plot the graph.
            subgraph = G.subgraph(component)
            nx.draw(subgraph, ax=ax, **properties, **kwargs)

            # Add them to their respective lists.
            pairs.append((fig, ax))

    return pairs if pairs else axes</code></pre>
</details>
</dd>
<dt id="evaltools.drawplan"><code class="name flex">
<span>def <span class="ident">drawplan</span></span>(<span>districts, assignment, overlay=None, colors=None, numbers=False, coloring='districtr')</span>
</code></dt>
<dd>
<div class="desc"><p>Visualizes the districting plan defined by <code>assignment</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>districts</code></strong></dt>
<dd>Geometries for the districting plan. Assumes there is one
geometry for each district.</dd>
<dt><strong><code>assignment</code></strong></dt>
<dd>Column of <code>districts</code> which defines the districting plan.</dd>
<dt><strong><code>overlay</code></strong></dt>
<dd>Optional; geodataframe to be plotted over the districts.
Often is a gdf of counties.</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>Optional; column name which specifies colors for each district.</dd>
<dt><strong><code>numbers</code></strong></dt>
<dd>Optional; if true, plots district names (as defined by
<code>assignment</code>) at districts' centroids.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>matplotlib</code> <code>Axes</code> object for the geometries attached to <code>districts</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawplan(
        districts, assignment, overlay=None, colors=None, numbers=False,
        coloring=&#34;districtr&#34;
    ):
    &#34;&#34;&#34;
    Visualizes the districting plan defined by `assignment`.

    Args:
        districts: Geometries for the districting plan. Assumes there is one
            geometry for each district.
        assignment: Column of `districts` which defines the districting plan.
        overlay: Optional; geodataframe to be plotted over the districts.
            Often is a gdf of counties.
        colors: Optional; column name which specifies colors for each district.
        numbers: Optional; if true, plots district names (as defined by
            `assignment`) at districts&#39; centroids.

    Returns:
        A `matplotlib` `Axes` object for the geometries attached to `districts`.
    &#34;&#34;&#34;
    # Sort districts by their assignment and add a column specifying the color
    # index.
    N = len(districts)
    districts = districts.to_crs(&#34;epsg:3857&#34;)
    districts[assignment] = districts[assignment].astype(int)
    districts = districts.sort_values(by=assignment)
    districts[&#34;colorindex&#34;] = list(range(N))

    # Assign colors.
    repeats = math.ceil(N/len(districtr))
    tail = districtr*(repeats-1)
    repeatedcolors = (districtr + (_riffle(tail) if tail else []))[:N]
    districts[&#34;color&#34;] = repeatedcolors

    # Plot the districts.
    base = districts.plot(
        color=districts[colors if colors else &#34;color&#34;],
        edgecolor=&#34;black&#34;,
        linewidth=1 if N&lt;=20 else 1/2
    )

    # If we have overlaid geometries, plot those too.
    if overlay is not None:
        overlay = overlay.to_crs(districts.crs)
        overlay.plot(color=&#34;None&#34;, edgecolor=&#34;black&#34;, linewidth=1/8, ax=base)
    
    # If the `numbers` flag is passed, plot the numbers for each district.
    if numbers:
        for district, identifier in zip(districts[&#34;geometry&#34;], districts[assignment]):
            x, y = list(district.centroid.coords)[0]
            base.annotate(
                identifier, (x, y), xytext=(x,y), xycoords=&#34;data&#34;, fontsize=6,
                ha=&#34;center&#34;, va=&#34;center&#34;,
                bbox=dict(
                    boxstyle=&#34;circle,pad=0.2&#34;, fc=&#34;white&#34;, ec=&#34;none&#34;, alpha=1
                )
            )

    # Turn plot axes off.
    plt.axis(&#34;off&#34;)

    return base</code></pre>
</details>
</dd>
<dt id="evaltools.dualgraph"><code class="name flex">
<span>def <span class="ident">dualgraph</span></span>(<span>geometries, index=None, geometrycolumn='geometry', colmap={}, buffer=0, edges_to_add=[], edges_to_cut=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a graph dual to the provided geometric data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometries</code></strong></dt>
<dd>Geometric data represented as a GeoDataFrame.</dd>
<dt><strong><code>index</code></strong></dt>
<dd>Unique identifiers; indexing column of <code>geometries</code>. If this
value is not set, vertex labels are integer indices; otherwise, vertex
labels are the values of this column.</dd>
<dt><strong><code>geometrycolumn</code></strong></dt>
<dd>Optional; name of <code>geoemtries</code>' geometry column.
Defaults to <code>"geometry"</code>.</dd>
<dt><strong><code>colmap</code></strong></dt>
<dd>Optional; maps old column names to new column names.</dd>
<dt><strong><code>buffer</code></strong></dt>
<dd>Optional; geometric buffer distance; defaults to <code>0</code>.</dd>
<dt><strong><code>edges_to_add</code></strong></dt>
<dd>Optional; edges to add to the graph object. Assumed to
be a list of pairs of objects, e.g. <code>[(u, v), &hellip;]</code> where <code>u</code> and <code>v</code> are
vertex labels consistent with <code>index</code>.</dd>
<dt><strong><code>edges_to_cut</code></strong></dt>
<dd>Optional; edges to cut from the graph object. Assumed to
be a list of pairs of objects, e.g. <code>[(u, v), &hellip;]</code> where <code>u</code> and <code>v</code> are
vertex labels consistent with <code>index</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A gerrychain <code><a title="evaltools.Graph" href="#evaltools.Graph">Graph</a></code> object dual to the geometric data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dualgraph(
        geometries, index=None, geometrycolumn=&#34;geometry&#34;, colmap={}, buffer=0,
        edges_to_add=[], edges_to_cut=[]
    ):
    &#34;&#34;&#34;
    Generates a graph dual to the provided geometric data.

    Args:
        geometries: Geometric data represented as a GeoDataFrame.
        index: Unique identifiers; indexing column of `geometries`. If this
            value is not set, vertex labels are integer indices; otherwise, vertex
            labels are the values of this column.
        geometrycolumn: Optional; name of `geoemtries`&#39; geometry column.
            Defaults to `&#34;geometry&#34;`.
        colmap: Optional; maps old column names to new column names.
        buffer: Optional; geometric buffer distance; defaults to `0`.
        edges_to_add: Optional; edges to add to the graph object. Assumed to
            be a list of pairs of objects, e.g. `[(u, v), ...]` where `u` and `v` are
            vertex labels consistent with `index`.
        edges_to_cut: Optional; edges to cut from the graph object. Assumed to
            be a list of pairs of objects, e.g. `[(u, v), ...]` where `u` and `v` are
            vertex labels consistent with `index`.

    Returns:
        A gerrychain `Graph` object dual to the geometric data.
    &#34;&#34;&#34;
    # Buffer geometries by default.
    geometries[geometrycolumn] = geometries.buffer(buffer)

    # Set indices and rename columns.
    if index: geometries = geometries.set_index(index)
    if colmap: geometries = geometries.rename(colmap, axis=1)

    # Generate the dual graph.
    dg = Graph.from_geodataframe(geometries)

    # Add and remove extraneous edges.
    for add in edges_to_add: dg.add_edge(*add)
    for cut in edges_to_cut: dg.remove_edge(*cut)

    # Return the graph!
    return dg</code></pre>
</details>
</dd>
<dt id="evaltools.pieces"><code class="name flex">
<span>def <span class="ident">pieces</span></span>(<span>P, units)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the number of "unit pieces" produced by the plan. For example,
consider a state with 100 counties. Suppose that one county is split twice,
and another in half. Then, there are 3 + 2 = 5 "pieces," disregarding the
counties kept whole.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong></dt>
<dd><code><a title="evaltools.Partition" href="#evaltools.Partition">Partition</a></code> object.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>List of data columns; each assigns a vertex to a unit. Generally,
these units are counties, VTDs, precincts, etc.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping column names to the number of splits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pieces(P, units):
    &#34;&#34;&#34;
    Determines the number of &#34;unit pieces&#34; produced by the plan. For example,
    consider a state with 100 counties. Suppose that one county is split twice,
    and another in half. Then, there are 3 + 2 = 5 &#34;pieces,&#34; disregarding the
    counties kept whole.
    
    Bear in mind that this calculates the number of *unit splits*, not the number
    of *units split*: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county 
    being split).

    Args:
        P: `Partition` object.
        units: List of data columns; each assigns a vertex to a unit. Generally,
            these units are counties, VTDs, precincts, etc.

    Returns:
        A dictionary mapping column names to the number of splits.
    &#34;&#34;&#34;
    geometrypieces = {
        unit: sum(
            len(value.contains) if len(value.contains) &gt; 1 else 0
            # Takes advantage of the fact that P is a Partition and `county_splits`
            # returns a function. We don&#39;t need to name the partition, and the
            # column of units being split by the plan are in `units`, so we can
            # simply call the function returned by `county_splits`, passing it
            # our Partition `P`.
            for value in county_splits(&#34;&#34;, unit)(P).values()
        )
        for unit in units
    }

    return geometrypieces</code></pre>
</details>
</dd>
<dt id="evaltools.redblue"><code class="name flex">
<span>def <span class="ident">redblue</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a red/white/blue color palette in <code>n</code> colors with white at the
<code>mid</code>th index.</p>
<p>:param midpoint: Integer; index of white.
:param n: Integer; number of colors.
:return: List; palette colors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redblue(n):
    &#34;&#34;&#34;
    Generates a red/white/blue color palette in `n` colors with white at the
    `mid`th index.
    
    :param midpoint: Integer; index of white.
    :param n: Integer; number of colors.
    :return: List; palette colors.
    &#34;&#34;&#34;
    blues = list(sns.color_palette(&#34;coolwarm&#34;, as_cmap=False, n_colors=(n-midpoint)*2))[:n-midpoint]
    reds = list(sns.color_palette(&#34;coolwarm&#34;, as_cmap=False, n_colors=midpoint*2))[midpoint:]
    
    return list(reversed(reds)) + list(reversed(blues))</code></pre>
</details>
</dd>
<dt id="evaltools.splits"><code class="name flex">
<span>def <span class="ident">splits</span></span>(<span>P, units)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the number of units split by the districting plan.</p>
<p>Bear in mind that this calculates the number of <em>unit splits</em>, not the number
of <em>units split</em>: for example, if a district divides a county into three
pieces, the former reports two splits (as a unit divided into three pieces is
cut twice), while the latter would report one split (as there is one county
being split).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong></dt>
<dd><code><a title="evaltools.Partition" href="#evaltools.Partition">Partition</a></code> object.</dd>
<dt><strong><code>units</code></strong></dt>
<dd>List of data columns; each assigns a vertex to a unit. Generally,
these units are counties, VTDs, precincts, etc.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping column names to the number of splits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splits(P, units):
    &#34;&#34;&#34;
    Determines the number of units split by the districting plan.
    
    Bear in mind that this calculates the number of *unit splits*, not the number
    of *units split*: for example, if a district divides a county into three
    pieces, the former reports two splits (as a unit divided into three pieces is
    cut twice), while the latter would report one split (as there is one county 
    being split).

    Args:
        P: `Partition` object.
        units: List of data columns; each assigns a vertex to a unit. Generally,
            these units are counties, VTDs, precincts, etc.
    
    Returns:
        A dictionary mapping column names to the number of splits.
    &#34;&#34;&#34;
    geometrysplits = {
        unit: sum(
            (len(value.contains))-1
            # Takes advantage of the fact that P is a Partition and `county_splits`
            # returns a function. We don&#39;t need to name the partition, and the
            # column of units being split by the plan are in `units`, so we can
            # simply call the function returned by `county_splits`, passing it
            # our Partition `P`.
            for value in county_splits(&#34;&#34;, unit)(P).values()
        )
        for unit in units
    }

    return geometrysplits</code></pre>
</details>
</dd>
<dt id="evaltools.unassigned"><code class="name flex">
<span>def <span class="ident">unassigned</span></span>(<span>P, raw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the proportion (or raw number) of units without a district
assignment. An unassigned unit is a unit without a districting assignment an
empty/corrupted assignment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>P</code></strong></dt>
<dd><code><a title="evaltools.Partition" href="#evaltools.Partition">Partition</a></code> object.</dd>
<dt><strong><code>raw</code></strong></dt>
<dd>Optional; if <code>True</code>, report the raw number of unassigned units.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>float</code> representing the proportion of units that are unassigned (or
the whole number of unassigned units).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unassigned(P, raw=False):
    &#34;&#34;&#34;
    Determines the proportion (or raw number) of units without a district
    assignment. An unassigned unit is a unit without a districting assignment an
    empty/corrupted assignment.

    Args:
        P: `Partition` object.
        raw: Optional; if `True`, report the raw number of unassigned units.
    
    Returns:
        `float` representing the proportion of units that are unassigned (or
        the whole number of unassigned units).
    &#34;&#34;&#34;
    assignment = P.assignment

    # Retrive the length of the assignment; this corresponds to the number of
    # units which have an assignment key.
    total = len(P.graph.nodes())

    # Next, check for &#34;bad&#34; assignments for units: this includes empty strings
    # and NaNs, for now.
    units_assigned_well = len({
        k: v
        for k, v in assignment.items() if v not in [&#34;nan&#34;, &#34;NaN&#34;, &#34;&#34;]
    })

    return 1-(units_assigned_well/total) if not raw else (total-units_assigned_well)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="evaltools.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>incoming_graph_data=None, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a graph to be partitioned. It is based on :class:<code>networkx.Graph</code>.</p>
<p>We have added some classmethods to help construct graphs from shapefiles, and
to save and load graphs as JSON files.</p>
<p>Initialize a graph with edges, name, or graph attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>incoming_graph_data</code></strong> :&ensp;<code>input graph (optional</code>, default<code>: None)</code></dt>
<dd>Data to initialize graph. If None (default) an empty
graph is created.
The data can be an edge list, or any
NetworkX graph object.
If the corresponding optional Python
packages are installed the data can also be a NumPy matrix
or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.</dd>
<dt><strong><code>attr</code></strong> :&ensp;<code>keyword arguments</code>, optional <code>(default= no attributes)</code></dt>
<dd>Attributes to add to graph as key=value pairs.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>convert</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc
&gt;&gt;&gt; G = nx.Graph(name=&quot;my graph&quot;)
&gt;&gt;&gt; e = [(1, 2), (2, 3), (3, 4)]  # list of edges
&gt;&gt;&gt; G = nx.Graph(e)
</code></pre>
<p>Arbitrary graph attribute pairs (key=value) may be assigned</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; G = nx.Graph(e, day=&quot;Friday&quot;)
&gt;&gt;&gt; G.graph
{'day': 'Friday'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(networkx.Graph):
    &#34;&#34;&#34;Represents a graph to be partitioned. It is based on :class:`networkx.Graph`.

    We have added some classmethods to help construct graphs from shapefiles, and
    to save and load graphs as JSON files.

    &#34;&#34;&#34;

    def __repr__(self):
        return &#34;&lt;Graph [{} nodes, {} edges]&gt;&#34;.format(len(self.nodes), len(self.edges))

    @classmethod
    def from_json(cls, json_file):
        &#34;&#34;&#34;Load a graph from a JSON file in the NetworkX json_graph format.
        :param json_file: Path to JSON file.
        :return: Graph
        &#34;&#34;&#34;
        with open(json_file) as f:
            data = json.load(f)
        g = json_graph.adjacency_graph(data)
        graph = cls(g)
        graph.issue_warnings()
        return graph

    def to_json(self, json_file, *, include_geometries_as_geojson=False):
        &#34;&#34;&#34;Save a graph to a JSON file in the NetworkX json_graph format.

        :param json_file: Path to target JSON file.
        :param bool include_geometry_as_geojson: (optional) Whether to include
            any :mod:`shapely` geometry objects encountered in the graph&#39;s node
            attributes as GeoJSON. The default (``False``) behavior is to remove
            all geometry objects because they are not serializable. Including the
            GeoJSON will result in a much larger JSON file.
        &#34;&#34;&#34;
        data = json_graph.adjacency_data(self)

        if include_geometries_as_geojson:
            convert_geometries_to_geojson(data)
        else:
            remove_geometries(data)

        with open(json_file, &#34;w&#34;) as f:
            json.dump(data, f)

    @classmethod
    def from_file(
        cls,
        filename,
        adjacency=&#34;rook&#34;,
        cols_to_add=None,
        reproject=False,
        ignore_errors=False,
    ):
        &#34;&#34;&#34;Create a :class:`Graph` from a shapefile (or GeoPackage, or GeoJSON, or
        any other library that :mod:`geopandas` can read. See :meth:`from_geodataframe`
        for more details.

        :param cols_to_add: (optional) The names of the columns that you want to
            add to the graph as node attributes. By default, all columns are added.
        &#34;&#34;&#34;
        df = gp.read_file(filename)
        graph = cls.from_geodataframe(
            df, adjacency=adjacency,
            cols_to_add=cols_to_add,
            reproject=reproject,
            ignore_errors=ignore_errors
        )

        return graph

    @classmethod
    def from_geodataframe(
        cls,
        dataframe,
        adjacency=&#34;rook&#34;,
        cols_to_add=None,
        reproject=False,
        ignore_errors=False
    ):
        &#34;&#34;&#34;Creates the adjacency :class:`Graph` of geometries described by `dataframe`.
        The areas of the polygons are included as node attributes (with key `area`).
        The shared perimeter of neighboring polygons are included as edge attributes
        (with key `shared_perim`).
        Nodes corresponding to polygons on the boundary of the union of all the geometries
        (e.g., the state, if your dataframe describes VTDs) have a `boundary_node` attribute
        (set to `True`) and a `boundary_perim` attribute with the length of this &#34;exterior&#34;
        boundary.

        By default, areas and lengths are computed in a UTM projection suitable for the
        geometries. This prevents the bizarro area and perimeter values that show up when
        you accidentally do computations in Longitude-Latitude coordinates. If the user
        specifies `reproject=False`, then the areas and lengths will be computed in the
        GeoDataFrame&#39;s current coordinate reference system. This option is for users who
        have a preferred CRS they would like to use.

        :param dataframe: :class:`geopandas.GeoDataFrame`
        :param adjacency: (optional) The adjacency type to use (&#34;rook&#34; or &#34;queen&#34;).
            Default is &#34;rook&#34;
        :param cols_to_add: (optional) The names of the columns that you want to
            add to the graph as node attributes. By default, all columns are added.
        :param reproject: (optional) Whether to reproject to a UTM projection before
            creating the graph. Default is ``True``.
        :param ignore_errors: (optional) Whether to ignore all invalid geometries and
            attept to create the graph anyway. Default is ``False``.
        :return: The adjacency graph of the geometries from `dataframe`.
        :rtype: :class:`Graph`
        &#34;&#34;&#34;
        # Validate geometries before reprojection
        if not ignore_errors:
            invalid = invalid_geometries(dataframe)
            if len(invalid) &gt; 0:
                raise GeometryError(
                    &#34;Invalid geometries at rows {} before &#34;
                    &#34;reprojection. Consider repairing the affected geometries with &#34;
                    &#34;`.buffer(0)`, or pass `ignore_errors=True` to attempt to create &#34;
                    &#34;the graph anyways.&#34;.format(invalid)
                )

        # Project the dataframe to an appropriate UTM projection unless
        # explicitly told not to.
        if reproject:
            df = reprojected(dataframe)
            if ignore_errors:
                invalid_reproj = invalid_geometries(df)
                print(invalid_reproj)
                if len(invalid_reproj) &gt; 0:
                    raise GeometryError(
                        &#34;Invalid geometries at rows {} after &#34;
                        &#34;reprojection. Consider reloading the GeoDataFrame with &#34;
                        &#34;`reproject=False` or repairing the affected geometries &#34;
                        &#34;with `.buffer(0)`.&#34;.format(invalid_reproj)
                    )
        else:
            df = dataframe

        # Generate dict of dicts of dicts with shared perimeters according
        # to the requested adjacency rule
        adjacencies = neighbors(df, adjacency)
        graph = cls(adjacencies)

        graph.geometry = df.geometry

        graph.issue_warnings()

        # Add &#34;exterior&#34; perimeters to the boundary nodes
        add_boundary_perimeters(graph, df.geometry)

        # Add area data to the nodes
        areas = df.geometry.area.to_dict()
        networkx.set_node_attributes(graph, name=&#34;area&#34;, values=areas)

        graph.add_data(df, columns=cols_to_add)
        return graph

    def add_data(self, df, columns=None):
        &#34;&#34;&#34;Add columns of a DataFrame to a graph as node attributes using
        by matching the DataFrame&#39;s index to node ids.

        :param df: Dataframe containing given columns.
        :param columns: (optional) List of dataframe column names to add.
        &#34;&#34;&#34;

        if columns is None:
            columns = list(df.columns)

        check_dataframe(df[columns])

        column_dictionaries = df.to_dict(&#34;index&#34;)
        networkx.set_node_attributes(self, column_dictionaries)

        if hasattr(self, &#34;data&#34;):
            self.data[columns] = df[columns]
        else:
            self.data = df[columns]

    def join(self, dataframe, columns=None, left_index=None, right_index=None):
        &#34;&#34;&#34;Add data from a dataframe to the graph, matching nodes to rows when
        the node&#39;s `left_index` attribute equals the row&#39;s `right_index` value.

        :param dataframe: DataFrame.
        :columns: (optional) The columns whose data you wish to add to the graph.
            If not provided, all columns are added.
        :left_index: (optional) The node attribute used to match nodes to rows.
            If not provided, node IDs are used.
        :right_index: (optional) The DataFrame column name to use to match rows
            to nodes. If not provided, the DataFrame&#39;s index is used.
        &#34;&#34;&#34;
        if right_index is not None:
            df = dataframe.set_index(right_index)
        else:
            df = dataframe

        if columns is not None:
            df = df[columns]

        check_dataframe(df)

        column_dictionaries = df.to_dict()

        if left_index is not None:
            ids_to_index = networkx.get_node_attributes(self, left_index)
        else:
            # When the left_index is node ID, the matching is just
            # a redundant {node: node} dictionary
            ids_to_index = dict(zip(self.nodes, self.nodes))

        node_attributes = {
            node_id: {
                column: values[index] for column, values in column_dictionaries.items()
            }
            for node_id, index in ids_to_index.items()
        }

        networkx.set_node_attributes(self, node_attributes)

    @property
    def islands(self):
        &#34;&#34;&#34;The set of degree-0 nodes.&#34;&#34;&#34;
        return set(node for node in self if self.degree[node] == 0)

    def warn_for_islands(self):
        &#34;&#34;&#34;Issue a warning if the graph has any islands (degree-0 nodes).&#34;&#34;&#34;
        islands = self.islands
        if len(self.islands) &gt; 0:
            warnings.warn(
                &#34;Found islands (degree-0 nodes). Indices of islands: {}&#34;.format(islands)
            )

    def issue_warnings(self):
        &#34;&#34;&#34;Issue warnings if the graph has any red flags (right now, only islands).&#34;&#34;&#34;
        self.warn_for_islands()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>networkx.classes.graph.Graph</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="evaltools.Graph.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>filename, adjacency='rook', cols_to_add=None, reproject=False, ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a :class:<code><a title="evaltools.Graph" href="#evaltools.Graph">Graph</a></code> from a shapefile (or GeoPackage, or GeoJSON, or
any other library that :mod:<code>geopandas</code> can read. See :meth:<code>from_geodataframe</code>
for more details.</p>
<p>:param cols_to_add: (optional) The names of the columns that you want to
add to the graph as node attributes. By default, all columns are added.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(
    cls,
    filename,
    adjacency=&#34;rook&#34;,
    cols_to_add=None,
    reproject=False,
    ignore_errors=False,
):
    &#34;&#34;&#34;Create a :class:`Graph` from a shapefile (or GeoPackage, or GeoJSON, or
    any other library that :mod:`geopandas` can read. See :meth:`from_geodataframe`
    for more details.

    :param cols_to_add: (optional) The names of the columns that you want to
        add to the graph as node attributes. By default, all columns are added.
    &#34;&#34;&#34;
    df = gp.read_file(filename)
    graph = cls.from_geodataframe(
        df, adjacency=adjacency,
        cols_to_add=cols_to_add,
        reproject=reproject,
        ignore_errors=ignore_errors
    )

    return graph</code></pre>
</details>
</dd>
<dt id="evaltools.Graph.from_geodataframe"><code class="name flex">
<span>def <span class="ident">from_geodataframe</span></span>(<span>dataframe, adjacency='rook', cols_to_add=None, reproject=False, ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the adjacency :class:<code><a title="evaltools.Graph" href="#evaltools.Graph">Graph</a></code> of geometries described by <code>dataframe</code>.
The areas of the polygons are included as node attributes (with key <code>area</code>).
The shared perimeter of neighboring polygons are included as edge attributes
(with key <code>shared_perim</code>).
Nodes corresponding to polygons on the boundary of the union of all the geometries
(e.g., the state, if your dataframe describes VTDs) have a <code>boundary_node</code> attribute
(set to <code>True</code>) and a <code>boundary_perim</code> attribute with the length of this "exterior"
boundary.</p>
<p>By default, areas and lengths are computed in a UTM projection suitable for the
geometries. This prevents the bizarro area and perimeter values that show up when
you accidentally do computations in Longitude-Latitude coordinates. If the user
specifies <code>reproject=False</code>, then the areas and lengths will be computed in the
GeoDataFrame's current coordinate reference system. This option is for users who
have a preferred CRS they would like to use.</p>
<p>:param dataframe: :class:<code>geopandas.GeoDataFrame</code>
:param adjacency: (optional) The adjacency type to use ("rook" or "queen").
Default is "rook"
:param cols_to_add: (optional) The names of the columns that you want to
add to the graph as node attributes. By default, all columns are added.
:param reproject: (optional) Whether to reproject to a UTM projection before
creating the graph. Default is <code>True</code>.
:param ignore_errors: (optional) Whether to ignore all invalid geometries and
attept to create the graph anyway. Default is <code>False</code>.
:return: The adjacency graph of the geometries from <code>dataframe</code>.
:rtype: :class:<code><a title="evaltools.Graph" href="#evaltools.Graph">Graph</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_geodataframe(
    cls,
    dataframe,
    adjacency=&#34;rook&#34;,
    cols_to_add=None,
    reproject=False,
    ignore_errors=False
):
    &#34;&#34;&#34;Creates the adjacency :class:`Graph` of geometries described by `dataframe`.
    The areas of the polygons are included as node attributes (with key `area`).
    The shared perimeter of neighboring polygons are included as edge attributes
    (with key `shared_perim`).
    Nodes corresponding to polygons on the boundary of the union of all the geometries
    (e.g., the state, if your dataframe describes VTDs) have a `boundary_node` attribute
    (set to `True`) and a `boundary_perim` attribute with the length of this &#34;exterior&#34;
    boundary.

    By default, areas and lengths are computed in a UTM projection suitable for the
    geometries. This prevents the bizarro area and perimeter values that show up when
    you accidentally do computations in Longitude-Latitude coordinates. If the user
    specifies `reproject=False`, then the areas and lengths will be computed in the
    GeoDataFrame&#39;s current coordinate reference system. This option is for users who
    have a preferred CRS they would like to use.

    :param dataframe: :class:`geopandas.GeoDataFrame`
    :param adjacency: (optional) The adjacency type to use (&#34;rook&#34; or &#34;queen&#34;).
        Default is &#34;rook&#34;
    :param cols_to_add: (optional) The names of the columns that you want to
        add to the graph as node attributes. By default, all columns are added.
    :param reproject: (optional) Whether to reproject to a UTM projection before
        creating the graph. Default is ``True``.
    :param ignore_errors: (optional) Whether to ignore all invalid geometries and
        attept to create the graph anyway. Default is ``False``.
    :return: The adjacency graph of the geometries from `dataframe`.
    :rtype: :class:`Graph`
    &#34;&#34;&#34;
    # Validate geometries before reprojection
    if not ignore_errors:
        invalid = invalid_geometries(dataframe)
        if len(invalid) &gt; 0:
            raise GeometryError(
                &#34;Invalid geometries at rows {} before &#34;
                &#34;reprojection. Consider repairing the affected geometries with &#34;
                &#34;`.buffer(0)`, or pass `ignore_errors=True` to attempt to create &#34;
                &#34;the graph anyways.&#34;.format(invalid)
            )

    # Project the dataframe to an appropriate UTM projection unless
    # explicitly told not to.
    if reproject:
        df = reprojected(dataframe)
        if ignore_errors:
            invalid_reproj = invalid_geometries(df)
            print(invalid_reproj)
            if len(invalid_reproj) &gt; 0:
                raise GeometryError(
                    &#34;Invalid geometries at rows {} after &#34;
                    &#34;reprojection. Consider reloading the GeoDataFrame with &#34;
                    &#34;`reproject=False` or repairing the affected geometries &#34;
                    &#34;with `.buffer(0)`.&#34;.format(invalid_reproj)
                )
    else:
        df = dataframe

    # Generate dict of dicts of dicts with shared perimeters according
    # to the requested adjacency rule
    adjacencies = neighbors(df, adjacency)
    graph = cls(adjacencies)

    graph.geometry = df.geometry

    graph.issue_warnings()

    # Add &#34;exterior&#34; perimeters to the boundary nodes
    add_boundary_perimeters(graph, df.geometry)

    # Add area data to the nodes
    areas = df.geometry.area.to_dict()
    networkx.set_node_attributes(graph, name=&#34;area&#34;, values=areas)

    graph.add_data(df, columns=cols_to_add)
    return graph</code></pre>
</details>
</dd>
<dt id="evaltools.Graph.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a graph from a JSON file in the NetworkX json_graph format.
:param json_file: Path to JSON file.
:return: Graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, json_file):
    &#34;&#34;&#34;Load a graph from a JSON file in the NetworkX json_graph format.
    :param json_file: Path to JSON file.
    :return: Graph
    &#34;&#34;&#34;
    with open(json_file) as f:
        data = json.load(f)
    g = json_graph.adjacency_graph(data)
    graph = cls(g)
    graph.issue_warnings()
    return graph</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="evaltools.Graph.islands"><code class="name">var <span class="ident">islands</span></code></dt>
<dd>
<div class="desc"><p>The set of degree-0 nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def islands(self):
    &#34;&#34;&#34;The set of degree-0 nodes.&#34;&#34;&#34;
    return set(node for node in self if self.degree[node] == 0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="evaltools.Graph.add_data"><code class="name flex">
<span>def <span class="ident">add_data</span></span>(<span>self, df, columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add columns of a DataFrame to a graph as node attributes using
by matching the DataFrame's index to node ids.</p>
<p>:param df: Dataframe containing given columns.
:param columns: (optional) List of dataframe column names to add.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_data(self, df, columns=None):
    &#34;&#34;&#34;Add columns of a DataFrame to a graph as node attributes using
    by matching the DataFrame&#39;s index to node ids.

    :param df: Dataframe containing given columns.
    :param columns: (optional) List of dataframe column names to add.
    &#34;&#34;&#34;

    if columns is None:
        columns = list(df.columns)

    check_dataframe(df[columns])

    column_dictionaries = df.to_dict(&#34;index&#34;)
    networkx.set_node_attributes(self, column_dictionaries)

    if hasattr(self, &#34;data&#34;):
        self.data[columns] = df[columns]
    else:
        self.data = df[columns]</code></pre>
</details>
</dd>
<dt id="evaltools.Graph.issue_warnings"><code class="name flex">
<span>def <span class="ident">issue_warnings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Issue warnings if the graph has any red flags (right now, only islands).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issue_warnings(self):
    &#34;&#34;&#34;Issue warnings if the graph has any red flags (right now, only islands).&#34;&#34;&#34;
    self.warn_for_islands()</code></pre>
</details>
</dd>
<dt id="evaltools.Graph.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, dataframe, columns=None, left_index=None, right_index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add data from a dataframe to the graph, matching nodes to rows when
the node's <code>left_index</code> attribute equals the row's <code>right_index</code> value.</p>
<p>:param dataframe: DataFrame.
:columns: (optional) The columns whose data you wish to add to the graph.
If not provided, all columns are added.
:left_index: (optional) The node attribute used to match nodes to rows.
If not provided, node IDs are used.
:right_index: (optional) The DataFrame column name to use to match rows
to nodes. If not provided, the DataFrame's index is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, dataframe, columns=None, left_index=None, right_index=None):
    &#34;&#34;&#34;Add data from a dataframe to the graph, matching nodes to rows when
    the node&#39;s `left_index` attribute equals the row&#39;s `right_index` value.

    :param dataframe: DataFrame.
    :columns: (optional) The columns whose data you wish to add to the graph.
        If not provided, all columns are added.
    :left_index: (optional) The node attribute used to match nodes to rows.
        If not provided, node IDs are used.
    :right_index: (optional) The DataFrame column name to use to match rows
        to nodes. If not provided, the DataFrame&#39;s index is used.
    &#34;&#34;&#34;
    if right_index is not None:
        df = dataframe.set_index(right_index)
    else:
        df = dataframe

    if columns is not None:
        df = df[columns]

    check_dataframe(df)

    column_dictionaries = df.to_dict()

    if left_index is not None:
        ids_to_index = networkx.get_node_attributes(self, left_index)
    else:
        # When the left_index is node ID, the matching is just
        # a redundant {node: node} dictionary
        ids_to_index = dict(zip(self.nodes, self.nodes))

    node_attributes = {
        node_id: {
            column: values[index] for column, values in column_dictionaries.items()
        }
        for node_id, index in ids_to_index.items()
    }

    networkx.set_node_attributes(self, node_attributes)</code></pre>
</details>
</dd>
<dt id="evaltools.Graph.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, json_file, *, include_geometries_as_geojson=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a graph to a JSON file in the NetworkX json_graph format.</p>
<p>:param json_file: Path to target JSON file.
:param bool include_geometry_as_geojson: (optional) Whether to include
any :mod:<code>shapely</code> geometry objects encountered in the graph's node
attributes as GeoJSON. The default (<code>False</code>) behavior is to remove
all geometry objects because they are not serializable. Including the
GeoJSON will result in a much larger JSON file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, json_file, *, include_geometries_as_geojson=False):
    &#34;&#34;&#34;Save a graph to a JSON file in the NetworkX json_graph format.

    :param json_file: Path to target JSON file.
    :param bool include_geometry_as_geojson: (optional) Whether to include
        any :mod:`shapely` geometry objects encountered in the graph&#39;s node
        attributes as GeoJSON. The default (``False``) behavior is to remove
        all geometry objects because they are not serializable. Including the
        GeoJSON will result in a much larger JSON file.
    &#34;&#34;&#34;
    data = json_graph.adjacency_data(self)

    if include_geometries_as_geojson:
        convert_geometries_to_geojson(data)
    else:
        remove_geometries(data)

    with open(json_file, &#34;w&#34;) as f:
        json.dump(data, f)</code></pre>
</details>
</dd>
<dt id="evaltools.Graph.warn_for_islands"><code class="name flex">
<span>def <span class="ident">warn_for_islands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Issue a warning if the graph has any islands (degree-0 nodes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warn_for_islands(self):
    &#34;&#34;&#34;Issue a warning if the graph has any islands (degree-0 nodes).&#34;&#34;&#34;
    islands = self.islands
    if len(self.islands) &gt; 0:
        warnings.warn(
            &#34;Found islands (degree-0 nodes). Indices of islands: {}&#34;.format(islands)
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="evaltools.Partition"><code class="flex name class">
<span>class <span class="ident">Partition</span></span>
<span>(</span><span>graph=None, assignment=None, updaters=None, parent=None, flips=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Partition represents a partition of the nodes of the graph. It will perform
the first layer of computations at each step in the Markov chain - basic
aggregations and calculations that we want to optimize.</p>
<p>:ivar gerrychain.Graph graph: The underlying graph.
:ivar gerrychain.Assignment assignment: Maps node IDs to district IDs.
:ivar dict parts: Maps district IDs to the set of nodes in that district.
:ivar dict subgraphs: Maps district IDs to the induced subgraph of that district.</p>
<p>:param graph: Underlying graph.
:param assignment: Dictionary assigning nodes to districts.
:param updaters: Dictionary of functions to track data about the partition.
The keys are stored as attributes on the partition class,
which the functions compute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Partition:
    &#34;&#34;&#34;
    Partition represents a partition of the nodes of the graph. It will perform
    the first layer of computations at each step in the Markov chain - basic
    aggregations and calculations that we want to optimize.

    :ivar gerrychain.Graph graph: The underlying graph.
    :ivar gerrychain.Assignment assignment: Maps node IDs to district IDs.
    :ivar dict parts: Maps district IDs to the set of nodes in that district.
    :ivar dict subgraphs: Maps district IDs to the induced subgraph of that district.
    &#34;&#34;&#34;

    default_updaters = {&#34;cut_edges&#34;: cut_edges}

    def __init__(
        self, graph=None, assignment=None, updaters=None, parent=None, flips=None
    ):
        &#34;&#34;&#34;
        :param graph: Underlying graph.
        :param assignment: Dictionary assigning nodes to districts.
        :param updaters: Dictionary of functions to track data about the partition.
            The keys are stored as attributes on the partition class,
            which the functions compute.
        &#34;&#34;&#34;
        if parent is None:
            self._first_time(graph, assignment, updaters)
        else:
            self._from_parent(parent, flips)

        self._cache = dict()
        self.subgraphs = SubgraphView(self.graph, self.parts)

    def _first_time(self, graph, assignment, updaters):
        self.graph = graph

        self.assignment = get_assignment(assignment, graph)

        if set(self.assignment) != set(graph):
            raise KeyError(&#34;The graph&#39;s node labels do not match the Assignment&#39;s keys&#34;)

        if updaters is None:
            updaters = dict()

        self.updaters = self.default_updaters.copy()
        self.updaters.update(updaters)

        self.parent = None
        self.flips = None
        self.flows = None
        self.edge_flows = None

    def _from_parent(self, parent, flips):
        self.parent = parent
        self.flips = flips

        self.assignment = parent.assignment.copy()
        self.assignment.update(flips)

        self.graph = parent.graph
        self.updaters = parent.updaters

        self.flows = flows_from_changes(parent.assignment, flips)
        self.edge_flows = compute_edge_flows(self)

    def __repr__(self):
        number_of_parts = len(self)
        s = &#34;s&#34; if number_of_parts &gt; 1 else &#34;&#34;
        return &#34;&lt;{} [{} part{}]&gt;&#34;.format(self.__class__.__name__, number_of_parts, s)

    def __len__(self):
        return len(self.parts)

    def flip(self, flips):
        &#34;&#34;&#34;Returns the new partition obtained by performing the given `flips`
        on this partition.

        :param flips: dictionary assigning nodes of the graph to their new districts
        :return: the new :class:`Partition`
        :rtype: Partition
        &#34;&#34;&#34;
        return self.__class__(parent=self, flips=flips)

    def crosses_parts(self, edge):
        &#34;&#34;&#34;Answers the question &#34;Does this edge cross from one part of the
        partition to another?

        :param edge: tuple of node IDs
        :rtype: bool
        &#34;&#34;&#34;
        return self.assignment[edge[0]] != self.assignment[edge[1]]

    def __getitem__(self, key):
        &#34;&#34;&#34;Allows accessing the values of updaters computed for this
        Partition instance.

        :param key: Property to access.
        &#34;&#34;&#34;
        if key not in self._cache:
            self._cache[key] = self.updaters[key](self)
        return self._cache[key]

    def __getattr__(self, key):
        return self[key]

    def keys(self):
        return self.updaters.keys()

    @property
    def parts(self):
        return self.assignment.parts

    def plot(self, geometries=None, **kwargs):
        &#34;&#34;&#34;Plot the partition, using the provided geometries.

        :param geometries: A :class:`geopandas.GeoDataFrame` or :class:`geopandas.GeoSeries`
            holding the geometries to use for plotting. Its :class:`~pandas.Index` should match
            the node labels of the partition&#39;s underlying :class:`~gerrychain.Graph`.
        :param `**kwargs`: Additional arguments to pass to :meth:`geopandas.GeoDataFrame.plot`
            to adjust the plot.
        &#34;&#34;&#34;
        if geometries is None:
            geometries = self.graph.geometry

        if set(geometries.index) != set(self.graph.nodes):
            raise TypeError(
                &#34;The provided geometries do not match the nodes of the graph.&#34;
            )
        assignment_series = self.assignment.to_series()
        if isinstance(geometries, geopandas.GeoDataFrame):
            geometries = geometries.geometry
        df = geopandas.GeoDataFrame(
            {&#34;assignment&#34;: assignment_series}, geometry=geometries
        )
        return df.plot(column=&#34;assignment&#34;, **kwargs)

    def get_num_spanning_trees(self, district):
        &#39;&#39;&#39;
        Given a district number, returns the number of spanning trees in the
        subgraph of self corresponding to the district.
        Uses Kirchoff&#39;s theorem to compute the number of spanning trees.

        :param self: :class:`gerrychain.Partition`
        :param district: A district in self
        :return: The number of spanning trees in the subgraph of self
        corresponding to district
        &#39;&#39;&#39;
        graph = self.subgraphs[district]
        laplacian = networkx.laplacian_matrix(graph)
        L = numpy.delete(numpy.delete(laplacian.todense(), 0, 0), 1, 1)
        return math.exp(numpy.linalg.slogdet(L)[1])

    @classmethod
    def from_districtr_file(cls, graph, districtr_file, updaters=None):
        &#34;&#34;&#34;Create a Partition from a districting plan created with `Districtr`_,
        a free and open-source web app created by MGGG for drawing districts.

        The provided ``graph`` should be created from the same shapefile as the
        Districtr module used to draw the districting plan. These shapefiles may
        be found in a repository in the `mggg-states`_ GitHub organization, or by
        request from MGGG.

        .. _`Districtr`: https://mggg.org/Districtr
        .. _`mggg-states`: https://github.com/mggg-states

        :param graph: :class:`~gerrychain.Graph`
        :param districtr_file: the path to the ``.json`` file exported from Districtr
        :param updaters: dictionary of updaters
        &#34;&#34;&#34;
        with open(districtr_file) as f:
            districtr_plan = json.load(f)

        id_column_key = districtr_plan[&#34;idColumn&#34;][&#34;key&#34;]
        districtr_assignment = districtr_plan[&#34;assignment&#34;]
        try:
            node_to_id = {node: str(graph.nodes[node][id_column_key]) for node in graph}
        except KeyError:
            raise TypeError(
                &#34;The provided graph is missing the {} column, which is &#34;
                &#34;needed to match the Districtr assignment to the nodes of the graph.&#34;
            )

        assignment = {node: districtr_assignment[node_to_id[node]] for node in graph}

        return cls(graph, assignment, updaters)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>gerrychain.partition.geographic.GeographicPartition</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="evaltools.Partition.default_updaters"><code class="name">var <span class="ident">default_updaters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="evaltools.Partition.from_districtr_file"><code class="name flex">
<span>def <span class="ident">from_districtr_file</span></span>(<span>graph, districtr_file, updaters=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Partition from a districting plan created with <code>Districtr</code>_,
a free and open-source web app created by MGGG for drawing districts.</p>
<p>The provided <code>graph</code> should be created from the same shapefile as the
Districtr module used to draw the districting plan. These shapefiles may
be found in a repository in the <code>mggg-states</code>_ GitHub organization, or by
request from MGGG.</p>
<p>.. <em><code>Districtr</code>: <a href="https://mggg.org/Districtr">https://mggg.org/Districtr</a>
.. </em><code>mggg-states</code>: <a href="https://github.com/mggg-states">https://github.com/mggg-states</a></p>
<p>:param graph: :class:<code>~gerrychain.Graph</code>
:param districtr_file: the path to the <code>.json</code> file exported from Districtr
:param updaters: dictionary of updaters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_districtr_file(cls, graph, districtr_file, updaters=None):
    &#34;&#34;&#34;Create a Partition from a districting plan created with `Districtr`_,
    a free and open-source web app created by MGGG for drawing districts.

    The provided ``graph`` should be created from the same shapefile as the
    Districtr module used to draw the districting plan. These shapefiles may
    be found in a repository in the `mggg-states`_ GitHub organization, or by
    request from MGGG.

    .. _`Districtr`: https://mggg.org/Districtr
    .. _`mggg-states`: https://github.com/mggg-states

    :param graph: :class:`~gerrychain.Graph`
    :param districtr_file: the path to the ``.json`` file exported from Districtr
    :param updaters: dictionary of updaters
    &#34;&#34;&#34;
    with open(districtr_file) as f:
        districtr_plan = json.load(f)

    id_column_key = districtr_plan[&#34;idColumn&#34;][&#34;key&#34;]
    districtr_assignment = districtr_plan[&#34;assignment&#34;]
    try:
        node_to_id = {node: str(graph.nodes[node][id_column_key]) for node in graph}
    except KeyError:
        raise TypeError(
            &#34;The provided graph is missing the {} column, which is &#34;
            &#34;needed to match the Districtr assignment to the nodes of the graph.&#34;
        )

    assignment = {node: districtr_assignment[node_to_id[node]] for node in graph}

    return cls(graph, assignment, updaters)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="evaltools.Partition.parts"><code class="name">var <span class="ident">parts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parts(self):
    return self.assignment.parts</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="evaltools.Partition.crosses_parts"><code class="name flex">
<span>def <span class="ident">crosses_parts</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Answers the question "Does this edge cross from one part of the
partition to another?</p>
<p>:param edge: tuple of node IDs
:rtype: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crosses_parts(self, edge):
    &#34;&#34;&#34;Answers the question &#34;Does this edge cross from one part of the
    partition to another?

    :param edge: tuple of node IDs
    :rtype: bool
    &#34;&#34;&#34;
    return self.assignment[edge[0]] != self.assignment[edge[1]]</code></pre>
</details>
</dd>
<dt id="evaltools.Partition.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self, flips)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the new partition obtained by performing the given <code>flips</code>
on this partition.</p>
<p>:param flips: dictionary assigning nodes of the graph to their new districts
:return: the new :class:<code><a title="evaltools.Partition" href="#evaltools.Partition">Partition</a></code>
:rtype: Partition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self, flips):
    &#34;&#34;&#34;Returns the new partition obtained by performing the given `flips`
    on this partition.

    :param flips: dictionary assigning nodes of the graph to their new districts
    :return: the new :class:`Partition`
    :rtype: Partition
    &#34;&#34;&#34;
    return self.__class__(parent=self, flips=flips)</code></pre>
</details>
</dd>
<dt id="evaltools.Partition.get_num_spanning_trees"><code class="name flex">
<span>def <span class="ident">get_num_spanning_trees</span></span>(<span>self, district)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a district number, returns the number of spanning trees in the
subgraph of self corresponding to the district.
Uses Kirchoff's theorem to compute the number of spanning trees.</p>
<p>:param self: :class:<code>gerrychain.Partition</code>
:param district: A district in self
:return: The number of spanning trees in the subgraph of self
corresponding to district</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_spanning_trees(self, district):
    &#39;&#39;&#39;
    Given a district number, returns the number of spanning trees in the
    subgraph of self corresponding to the district.
    Uses Kirchoff&#39;s theorem to compute the number of spanning trees.

    :param self: :class:`gerrychain.Partition`
    :param district: A district in self
    :return: The number of spanning trees in the subgraph of self
    corresponding to district
    &#39;&#39;&#39;
    graph = self.subgraphs[district]
    laplacian = networkx.laplacian_matrix(graph)
    L = numpy.delete(numpy.delete(laplacian.todense(), 0, 0), 1, 1)
    return math.exp(numpy.linalg.slogdet(L)[1])</code></pre>
</details>
</dd>
<dt id="evaltools.Partition.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self.updaters.keys()</code></pre>
</details>
</dd>
<dt id="evaltools.Partition.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, geometries=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the partition, using the provided geometries.</p>
<p>:param geometries: A :class:<code>geopandas.GeoDataFrame</code> or :class:<code>geopandas.GeoSeries</code>
holding the geometries to use for plotting. Its :class:<code>~pandas.Index</code> should match
the node labels of the partition's underlying :class:<code>~gerrychain.Graph</code>.
:param <code>**kwargs</code>: Additional arguments to pass to :meth:<code>geopandas.GeoDataFrame.plot</code>
to adjust the plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, geometries=None, **kwargs):
    &#34;&#34;&#34;Plot the partition, using the provided geometries.

    :param geometries: A :class:`geopandas.GeoDataFrame` or :class:`geopandas.GeoSeries`
        holding the geometries to use for plotting. Its :class:`~pandas.Index` should match
        the node labels of the partition&#39;s underlying :class:`~gerrychain.Graph`.
    :param `**kwargs`: Additional arguments to pass to :meth:`geopandas.GeoDataFrame.plot`
        to adjust the plot.
    &#34;&#34;&#34;
    if geometries is None:
        geometries = self.graph.geometry

    if set(geometries.index) != set(self.graph.nodes):
        raise TypeError(
            &#34;The provided geometries do not match the nodes of the graph.&#34;
        )
    assignment_series = self.assignment.to_series()
    if isinstance(geometries, geopandas.GeoDataFrame):
        geometries = geometries.geometry
    df = geopandas.GeoDataFrame(
        {&#34;assignment&#34;: assignment_series}, geometry=geometries
    )
    return df.plot(column=&#34;assignment&#34;, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="evaltools.assignment_schema"><code class="flex name class">
<span>class <span class="ident">assignment_schema</span></span>
<span>(</span><span>TOTPOP, num_cut_edges, seats, contiguity, population_assigned, unassigned_units)</span>
</code></dt>
<dd>
<div class="desc"><p>assignment_schema(TOTPOP, num_cut_edges, seats, contiguity, population_assigned, unassigned_units)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="evaltools.assignment_schema.TOTPOP"><code class="name">var <span class="ident">TOTPOP</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="evaltools.assignment_schema.contiguity"><code class="name">var <span class="ident">contiguity</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="evaltools.assignment_schema.num_cut_edges"><code class="name">var <span class="ident">num_cut_edges</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="evaltools.assignment_schema.population_assigned"><code class="name">var <span class="ident">population_assigned</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="evaltools.assignment_schema.seats"><code class="name">var <span class="ident">seats</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="evaltools.assignment_schema.unassigned_units"><code class="name">var <span class="ident">unassigned_units</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
</dl>
</dd>
<dt id="evaltools.ensemble_schema"><code class="flex name class">
<span>class <span class="ident">ensemble_schema</span></span>
<span>(</span><span>type, num_districts, epsilon, chain_type, pop_col, metrics, pov_party, elections, party_statewide_share)</span>
</code></dt>
<dd>
<div class="desc"><p>ensemble_schema(type, num_districts, epsilon, chain_type, pop_col, metrics, pov_party, elections, party_statewide_share)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="evaltools.ensemble_schema.chain_type"><code class="name">var <span class="ident">chain_type</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="evaltools.ensemble_schema.elections"><code class="name">var <span class="ident">elections</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 7</p></div>
</dd>
<dt id="evaltools.ensemble_schema.epsilon"><code class="name">var <span class="ident">epsilon</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="evaltools.ensemble_schema.metrics"><code class="name">var <span class="ident">metrics</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="evaltools.ensemble_schema.num_districts"><code class="name">var <span class="ident">num_districts</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="evaltools.ensemble_schema.party_statewide_share"><code class="name">var <span class="ident">party_statewide_share</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 8</p></div>
</dd>
<dt id="evaltools.ensemble_schema.pop_col"><code class="name">var <span class="ident">pop_col</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="evaltools.ensemble_schema.pov_party"><code class="name">var <span class="ident">pov_party</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 6</p></div>
</dd>
<dt id="evaltools.ensemble_schema.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="evaltools.auxiliary" href="auxiliary/index.html">evaltools.auxiliary</a></code></li>
<li><code><a title="evaltools.colors" href="colors.html">evaltools.colors</a></code></li>
<li><code><a title="evaltools.evaluation" href="evaluation/index.html">evaltools.evaluation</a></code></li>
<li><code><a title="evaltools.geography" href="geography/index.html">evaltools.geography</a></code></li>
<li><code><a title="evaltools.mapping" href="mapping/index.html">evaltools.mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="evaltools.contiguous" href="#evaltools.contiguous">contiguous</a></code></li>
<li><code><a title="evaltools.deviations" href="#evaltools.deviations">deviations</a></code></li>
<li><code><a title="evaltools.dissolve" href="#evaltools.dissolve">dissolve</a></code></li>
<li><code><a title="evaltools.drawgraph" href="#evaltools.drawgraph">drawgraph</a></code></li>
<li><code><a title="evaltools.drawplan" href="#evaltools.drawplan">drawplan</a></code></li>
<li><code><a title="evaltools.dualgraph" href="#evaltools.dualgraph">dualgraph</a></code></li>
<li><code><a title="evaltools.pieces" href="#evaltools.pieces">pieces</a></code></li>
<li><code><a title="evaltools.redblue" href="#evaltools.redblue">redblue</a></code></li>
<li><code><a title="evaltools.splits" href="#evaltools.splits">splits</a></code></li>
<li><code><a title="evaltools.unassigned" href="#evaltools.unassigned">unassigned</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="evaltools.Graph" href="#evaltools.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="evaltools.Graph.add_data" href="#evaltools.Graph.add_data">add_data</a></code></li>
<li><code><a title="evaltools.Graph.from_file" href="#evaltools.Graph.from_file">from_file</a></code></li>
<li><code><a title="evaltools.Graph.from_geodataframe" href="#evaltools.Graph.from_geodataframe">from_geodataframe</a></code></li>
<li><code><a title="evaltools.Graph.from_json" href="#evaltools.Graph.from_json">from_json</a></code></li>
<li><code><a title="evaltools.Graph.islands" href="#evaltools.Graph.islands">islands</a></code></li>
<li><code><a title="evaltools.Graph.issue_warnings" href="#evaltools.Graph.issue_warnings">issue_warnings</a></code></li>
<li><code><a title="evaltools.Graph.join" href="#evaltools.Graph.join">join</a></code></li>
<li><code><a title="evaltools.Graph.to_json" href="#evaltools.Graph.to_json">to_json</a></code></li>
<li><code><a title="evaltools.Graph.warn_for_islands" href="#evaltools.Graph.warn_for_islands">warn_for_islands</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="evaltools.Partition" href="#evaltools.Partition">Partition</a></code></h4>
<ul class="">
<li><code><a title="evaltools.Partition.crosses_parts" href="#evaltools.Partition.crosses_parts">crosses_parts</a></code></li>
<li><code><a title="evaltools.Partition.default_updaters" href="#evaltools.Partition.default_updaters">default_updaters</a></code></li>
<li><code><a title="evaltools.Partition.flip" href="#evaltools.Partition.flip">flip</a></code></li>
<li><code><a title="evaltools.Partition.from_districtr_file" href="#evaltools.Partition.from_districtr_file">from_districtr_file</a></code></li>
<li><code><a title="evaltools.Partition.get_num_spanning_trees" href="#evaltools.Partition.get_num_spanning_trees">get_num_spanning_trees</a></code></li>
<li><code><a title="evaltools.Partition.keys" href="#evaltools.Partition.keys">keys</a></code></li>
<li><code><a title="evaltools.Partition.parts" href="#evaltools.Partition.parts">parts</a></code></li>
<li><code><a title="evaltools.Partition.plot" href="#evaltools.Partition.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="evaltools.assignment_schema" href="#evaltools.assignment_schema">assignment_schema</a></code></h4>
<ul class="two-column">
<li><code><a title="evaltools.assignment_schema.TOTPOP" href="#evaltools.assignment_schema.TOTPOP">TOTPOP</a></code></li>
<li><code><a title="evaltools.assignment_schema.contiguity" href="#evaltools.assignment_schema.contiguity">contiguity</a></code></li>
<li><code><a title="evaltools.assignment_schema.num_cut_edges" href="#evaltools.assignment_schema.num_cut_edges">num_cut_edges</a></code></li>
<li><code><a title="evaltools.assignment_schema.population_assigned" href="#evaltools.assignment_schema.population_assigned">population_assigned</a></code></li>
<li><code><a title="evaltools.assignment_schema.seats" href="#evaltools.assignment_schema.seats">seats</a></code></li>
<li><code><a title="evaltools.assignment_schema.unassigned_units" href="#evaltools.assignment_schema.unassigned_units">unassigned_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="evaltools.ensemble_schema" href="#evaltools.ensemble_schema">ensemble_schema</a></code></h4>
<ul class="">
<li><code><a title="evaltools.ensemble_schema.chain_type" href="#evaltools.ensemble_schema.chain_type">chain_type</a></code></li>
<li><code><a title="evaltools.ensemble_schema.elections" href="#evaltools.ensemble_schema.elections">elections</a></code></li>
<li><code><a title="evaltools.ensemble_schema.epsilon" href="#evaltools.ensemble_schema.epsilon">epsilon</a></code></li>
<li><code><a title="evaltools.ensemble_schema.metrics" href="#evaltools.ensemble_schema.metrics">metrics</a></code></li>
<li><code><a title="evaltools.ensemble_schema.num_districts" href="#evaltools.ensemble_schema.num_districts">num_districts</a></code></li>
<li><code><a title="evaltools.ensemble_schema.party_statewide_share" href="#evaltools.ensemble_schema.party_statewide_share">party_statewide_share</a></code></li>
<li><code><a title="evaltools.ensemble_schema.pop_col" href="#evaltools.ensemble_schema.pop_col">pop_col</a></code></li>
<li><code><a title="evaltools.ensemble_schema.pov_party" href="#evaltools.ensemble_schema.pov_party">pov_party</a></code></li>
<li><code><a title="evaltools.ensemble_schema.type" href="#evaltools.ensemble_schema.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>